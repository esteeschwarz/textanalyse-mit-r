[["index.html", "Textanalyse mit R für die Geisteswissenschaften Über diesen Kurs", " Textanalyse mit R für die Geisteswissenschaften Lisa Poggel SoSe 2024 Freie Universität Berlin Über diesen Kurs Willkommen in meinem Seminar “Textanalyse mit R für die Geisteswissenschaften”! Hier findet ihr die Inhalte zu allen Sitzungen. Dieses Seminar vermittelt grundlegende praktische Kenntnisse der Textanalyse mit der Programmiersprache R. Der Fokus liegt auf der Verarbeitung und Analyse geisteswissenschaftlicher Daten. Das Seminar richtet sich insbesondere an Studierende ohne Programmiererfahrung und vermittelt neben Verfahren der Textanalyse und des Text Mining auch Grundlagen der Programmierung mit R. R kommt als besonders einstiegsfreundliche Programmiersprache vermehrt auch in geisteswissenschaftlichen Forschungsprojekten zur Anwendung, beispielsweise bei der quantitativen Textanalyse, in der digitalen Stilometrie, bei der Autorschaftserkennung oder zur Analyse und Visualisierung historischer Korrespondenznetzwerke. Das Seminar setzt keine Programmiererfahrung voraus. "],["warum-r.html", "Warum R? Was ist R überhaupt? R Thirst Traps", " Warum R? Was ist R überhaupt? R is a language and environment for statistical computing and graphics. Quelle: https://www.r-project.org/about.html Warum sollten Geisteswissenschaftler:innen eine Programmiersprache für “statistical computing” lernen? Kann man damit nicht nur Worthäufigkeiten zählen und Wortwolken erstellen? Und sind Wortwolken nicht irgendwie etwas “underwhelming”? In den letzten Jahren ist R neben Python zur meistgenutzten Programmiersprache im Bereich Data Science geworden. Data Scientists beschäftigen sich natürlich tatsächlich viel mit Statistik. Aber R ist viel mehr als “nur” Statistik. Die Anwendungsmöglichkeiten von R sind genauso vielfältig wie die Digital Humanities selbst. Und das nicht nur, weil die Digital Humanities selbst ein sehr vielseitiges Fach sind, über deren Definition immer noch kontrovers diskutiert wird (siehe zum Beispiel whatisdigitalhumanities.com). R hat eine aktive und riesige Community von Nutzer:innen, die immer neue sogenannte “Pakete” erstellen, die für bestimmte Anwendungen gemacht sind, wie zum Beispiel für die Analyse dramatischer Texte, die Stilometrie oder auch die Textanalyse ganz allgemein. Was man alles so mit R in den Digital Humanities anstellen kann, illustrieren die Beispiele im nächsten Abschnitt. R Thirst Traps Das klingt alles bisher noch sehr abstrakt. Deswegen hier ein paar ganz konkrete Anwendungsbeispiele von R im Bereich der Digital Humanities, die hoffentlich etwas Lust auf R machen: Web App, Geocoding, GIS, Queere Geschichte: https://www.mappingthegayguides.org/map/ Code zum Projekt: https://github.com/MappingtheGayGuides/MGG-App Rezeptionsforschung zu James Baldwin, Literaturgeschichte, Datenvisualisierung: https://tweetsofanativeson.com/Seattle-Public-Library-2023/ Code: https://github.com/JoeLollo21/Viral-Lit-Project Text Reuse und Intertextualität: https://americaspublicbible.org/ , https://americaspublicbible.supdigital.org/verse-viewer/?ref=Proverbs%2022%3A6 Code: https://github.com/lmullen/americas-public-bible Text Reuse in historischen Zeitschriften, Topic Modeling, Text Feature Extraction: https://viraltexts.org/ Code: https://github.com/rccordell/us-newspapers-1689-2009 ; https://github.com/ViralTexts/viral-texts-networks ; https://github.com/jonathandfitzgerald/Viral-Texts-R Topic Modeling: https://layeredlives.org/ Publikation zum Projekt: https://statsmaths.github.io/pdf/2022-layered-lives.pdf Named Entity Recognition und Textannotation: https://photogrammar.org Code: https://github.com/americanpanorama/photogrammar Korrespondenznetzwerk analysieren und visualisieren: https://www.jessesadler.com/project/dvdm-correspondence Code: https://github.com/jessesadler/dvdm-correspondence Quantitative Textanalyse von Shakespeare-Dramen, Datenbeschaffung: https://m-clark.github.io/text-analysis-with-R/shakespeare.html Dramenanalyse, Arbeit mit XML-TEI Dateien: https://quadrama.github.io/DramaAnalysis/tutorial/3/introduction.html Code: https://github.com/quadrama/DramaAnalysis Datenbeschaffung mithilfe von APIs (Codebeispiel): https://github.com/ThomasK81/ExploringDigitalHumanities/blob/master/RScripts/shortstories.R Textklassifikation (Codesammlung): https://github.com/kbenoit/newsmap Quantitative Inhaltsanalyse mit R, Kookkurrenzen von Charakteren in “Sherlock Holmes”: http://inhaltsanalyse-mit-r.de/netzwerke.html Lexikalische Vielfalt und Sentimentanalyse (Codesammlung): https://github.com/louismagowan/lyrics_analysis Lexikalische Ähnlichkeit von Romanen, Computational Linguistics, Stemming Publikation zum Projekt: https://piperlab.mcgill.ca/pdfs/Piper_NovelConversions.pdf Code: https://github.com/nan-da/Novel-Devotions Genreklassifikation, Topic Modeling, soziale Netzwerkanalyse, Part of Speech Tagging, uvm. Publikation: https://press.uchicago.edu/ucp/books/book/chicago/E/bo28465405.html Code: https://github.com/piperandrew/enumerations Computational Linguistics, Named Entity Recognition, Part of Speech Tagging: Publikation: https://amst.winter-verlag.de/article/AMST/2018/2/8 Code: https://github.com/nilsreiter/rereading-the-american-short-story Quantitative Linguistik, Korpuslinguistik: https://jupyter.korpus.cz/shiny/lukes/mda/ Code: https://github.com/dlukes/shiny-mda Digital Humanities Masterarbeit, in der R verwendet wird (Codesammlung): https://github.com/mikkosk/spectator_masters_thesis Noch eine Digital Humanities Masterarbeit (von mir): https://lipogg.shinyapps.io/soviet-ethnography/ Code: https://github.com/lipogg/soviet-ethnography Im Laufe des Semesters werden wir also nicht (nur) Wordclouds erstellen, sondern genuin geistes- bzw. literaturwissenschaftlichen Fragestellungen und Technologien behandeln, die für die geisteswissenschaftliche Arbeit relevant sind. Dabei sollen programmatische Zugriffe auf diese Fragestellungen natürlich traditionelle Analysemethoden nicht ersetzen, sondern diese produktiv ergänzen. "],["seminarplan.html", "Seminarplan", " Seminarplan Sitzung Nr. Datum Thema 1 16.4. Einstieg 2 23.4. R Basics I: Datentypen, Variablen und Operatoren 3, 4 30.4., 7.5. R Basics II: Datenstrukturen 5 14.5. R Basics III: Kontrollstrukturen 6 21.5. R Basics IV: Funktionen und Pakete 7 28.5. R Basics Wiederholung 8 4.6. Textanalyse mit Quanteda I: Korpus, Tokens, Daten und Dateien 9 11.6. Textanalyse mit Quanteda II: Preprocessing und Reguläre Ausdrücke 10 18.6. Textanalyse mit Quanteda III: Wortfrequenzanalysen 11 25.6. Part of Speech Tagging und Dependency Parsing mit UDPipe 12 2.7. Textanalyse Wiederholung 13 9.7. Named Entity Recognition 14 16.7. Arbeit mit XML-TEI Dateien: XML, TEI und XPath Die Sitzung am 11.6. findet ONLINE statt. Der Seminarplan ist erst einmal vorläufig. Je nach Lerntempo und Interessen werden wir das ein oder andere Thema mehr oder weniger vertiefen. Die Inhalte bauen grundsätzlich aufeinander auf: Zunächst beschäftigen wir uns mit sogenannten “unstrukturierten” Daten und später mit “(semi-)strukturierten” Daten. Nach einem Einstieg in R steigen wir in die Arbeit mit “rohem Text”, also Plaintext-Dateien, als Beispiel für unstrukturierte Daten ein und erarbeiten Grundkonzepte der quantitativen Textanalyse. Dabei werden wir auch diskutieren, was “geisteswissenschaftliche Daten” eigentlich sind. Danach behandeln wir zwei verschiedene Verfahren, wie Texte in R im Hinblick auf bestimmte Textinformationen strukturiert (man sagt auch “annotiert”) werden können: das automatisierte Erkennen von Wortarten (Part of Speech Tagging) und von “Entitäten” wie Personennamen und Ortsnamen (Named Entity Recognition). Zuletzt widmen wir uns XML-TEI-Dateien als Beispiel für die Analyse (semi-)strukturierter Textdaten. XML-TEI ist ein in den Digital Humanities weit verbreiteter Standard zur digitalen Darstellung von Texten, beispielsweise literarsichen Werken, archivalischen Quellen oder wissenschaftlichen Arbeiten. Mithilfe von XML-TEI können Textinformationen, zum Beispiel Metadaten und bestimmte Bestandteile des Textes, strukturiert dargestellt werden. Die vorgestellten Verfahren können wir natürlich in der kurzen Zeit nur sehr, sehr oberflächlich behandeln. Das Ziel ist es, dass ihr am Ende des Semesters Grundkonzepte des Programmierens in R und grundlegende Anwendungen der Programmiersprache im Bereich der Textanalyse kennt und euch die Fertigkeiten erarbeitet habt, fortgeschrittenere Themen eigenständig weiter zu vertiefen. Da wir viele Themen besprechen werden, erfordert dieses Seminar ein hohes Maß an Motivation und Durchhaltevermögen. Jede Woche wird es Übungsaufgaben geben. Die Bearbeitung der Übungsaufgaben ist verpflichtend und insbesondere zur Vor- und Nachbereitung der Einstiegssitzungen essentiell, denn sonst wird es sehr schwierig sein, später mitzukommen. Die Lernkurve ist demenstprechend steil: "],["lernziele.html", "Lernziele", " Lernziele Das Seminar ist als Praxisseminar konzipiert. Das heißt, dass der Fokus darauf liegt, anhand praktischer Übungsaufgaben und Fragestellungen das Coden in R zu erlernen. Das heißt aber nicht, dass wir nur Sachen auswendig lernen und Inhalte von einem Zusammenhang auf den anderen übertragen. Die kritische Analyse und Evaluation nicht nur von Code sondern auch von konkreten Verfahren ist essentiell für die Arbeit mit geisteswissenschaftlichen Daten. Nach diesem Seminar kennt ihr… Grundbegriffe und Konzepte der Programmierung mit R: Die Studierenden kennen den Unterschied zwischen verschiedenen Datentypen und Datenstrukturen und kennen die wichtigsten Operationen darauf. Sie haben ein Grundverständnis von der sinnvollen Strukturierung von R-Code und kennen wichtige Konventionen. Grundbegriffe und Verfahren der Textanalyse und -aufbereitung mit R: Die Studierenden kennen geeignete Verfahren zur Aufbereitung und Analyse von Plaintext-Dateien und XML-TEI-Dateien. Sie können mögliche Probleme, Vor- und Nachteile der verschiedenen Verfahren sowie ausgewählte Anwendungsgebiete der Verfahren benennen. Sie kennen relevante Richtwerte und Metriken zur Bewertung der Analyseergebnisse und haben ein elementares Verständnis der statistischen Grundlagen der angewandten Verfahren. Datenformate: Die Studierenden sind mit dem Aufbau von XML-TEI Dokumenten vertraut. Sie können zwischen verschiedenen Datenformaten unterscheiden. Suchtechniken für verschiedene Datenformate: Die Studierenden kennen die grundlegende Syntax von Regulären Ausdrücken und XPath. Nach diesem Seminar könnt ihr … Verfahren des Preprocessing und der Textanalyse in R anwenden: Die Studierenden können R-Code lesen und (je nach Vorkenntnissen) einfache bis fortgeschrittene Skripte zum Preprocessing und Analyse von Textdaten in R selbst schreiben. Sie können Fehler mithilfe von Debugging-Strategien selbst identifizieren und können Online-Ressourcen nutzen, um sich selbst Hilfe zu beschaffen. Sie können komplexen Code auf dem eigenen Computer reproduzieren. Sie sind routiniert im Umgang mit RStudio. Sie können einfache Ausdrücke zur Suche in Plaintext- und XML-TEI-Dateien mithilfe von Regulären Ausdrücken und XPath schreiben und einsetzen. Auswirkungen der angewandten Verfahren evaluieren: Die Studierenden können evaluieren, wie sich verschiedene Entscheidungen und Verfahren des Preprocessing auf die Analyse eines Textkorpus’ auswirken. Sie können identifizieren, welche Preprocessing-Schritte die Analyseergebnisse verbessern können. Aussagekraft der Ergebnisse kritisch bewerten: Die Studierenden können die Ergebnisse der verschiedenen Analyse-, Such und Extraktionsverfahren im Hinblick auf die Preprocessingentscheidungen, die Qualität und Zusammensetzung des Korpus kritisch bewerten. "],["organisatorisches.html", "Organisatorisches", " Organisatorisches Hier findet ihr Informationen zu Teilnahmemodalitäten, Prüfungsleistungen und Kommunikation. Teilnahmeschein: Aktive Teilnahme: n-2 Sitzungen Wöchentliche Übungsaufgaben: Lösungen Montagabend vor jeder Stunde an mich schicken (l.poggel@fu-berlin.de). Übungen schicke ich euch per Mail jede Woche Mittwoch. Ein Kahoot-Quiz erstellen und moderieren. Login über https://kahoot.com/ Leistungsschein: Wie Teilnahmeschein Zusätzlich ein eigenständiges Projekt (ersetzt die Hausarbeit): Ihr plant und implementiert auf der Grundlage der Inhalte aus diesem Seminar ein kleines Digital Humanities Projekt. Im Laufe der Bearbeitung eurer Fragestellung erstellt ihr ein kleines Programmierportfolio mit allen Skripten, die ihr im Rahmen des Projekts erstellt habt. Das Portfolio sendet ihr als Zip-Ordner bis zum 30.09.2024 an l.poggel@fu-berlin.de. Die Anforderungen, Projektbeispiele und die Bewertungsgrundlage für das Portfolio besprechen wir rechtzeitig im Laufe des Semesters. Kommunikation: Bei Fragen, Kritik oder falls ihr mal eine Sitzung nicht kommen könnt, schreibt mir eine E-Mail an l.poggel@fu-berlin.de. Um eine Sprechstunde zu vereinbaren, könnt ihr mich gern vor oder nach den Sitzungen ansprechen oder mir eine E-Mail schreiben. Bewertungskriterien für das Abschlussprojekt: Umfang: Programmierportfolio, bestehend aus mindestens zwei verschiedenen R Skripten und einer Dokumentationsseite, die die Fragestellung, das Korpus, den Forschungsstand und die gewählten Verfahren vorstellt und begründet, sowie die Ergebnisse in Bezug auf die Fragestellung auswertet (4-8 Seiten). Abgabefrist: 30.09.2024 Abgabeformat: Programmierportfolio als Zip-Ordner Beispielportfolio: Skript 1: Preprocessing. Vorbereitetes Korpus wird in RDS-Datei gespeichert. Skript 2: Analyse mit quanteda, UDPipe (oder Named Entity Recognition). Das Korpus wird aus der RDS-Datei eingelesen. Dokumentation als RMarkdown-Dokument oder PDF Bewertungsskala: Note Erläuterung 1.0-1.3 Alle formalen Kriterien werden eingehalten. Die Forschungsfrage ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren sehr gut beantwortbar. Es gibt dabei unter den im Kurs kennengelernten Verfahren keine besser geeigneten Verfahren zur Beantwortung der Fragestellung. Die Wahl der verwendeten Verfahren, Vor- und Nachteile, die Aussagekraft sowie mögliche Auswirkungen auf die Beantwortung der Fragestellung werden kritisch diskutiert. Die Aussagekraft des Analyseverfahrens wird kritisch diskutiert. Die Ergebnisse werden in Bezug zum aktuellen Forschungsstand gesetzt. Der Code ist ausführlich kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen und folgt immer gängigen stilistischen Konventionen und Regeln. 1.3-2.3 Alle formalen Kriterien werden eingehalten. Die Fragestellung ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar, aber es gibt ein besser geeignetes Verfahren. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht gänzlich überzeugend oder weniger wichtige Konsequenzen der Entscheidung werden nicht diskutiert. Die Aussagekraft des Analyseverfahrens wird kritisch diskutiert. Die Ergebnisse werden in Bezug zum aktuellen Forschungsstand gesetzt. Der Code ist ausführlich kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen und folgt zumeist gängigen stilistischen Konventionen und Regeln. 2.3-3.3 Alle formalen Kriterien werden eingehalten. Die Fragestellung ist sinnvoll und mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar, aber es gibt ein besser geeignetes Verfahren. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht überzeugend. Der Code ist an den wichtigsten Stellen kommentiert. Fremder Code wird nur dann verwendet, wenn der Code für die Umsetzung von Aufgaben, die über die Inhalte im Seminar hinausgehen, gebraucht wird, oder, wenn der Code eine Verbesserung zu den im Seminar vorgestellten Vorgehen darstellt. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. 3.3-4.0 Formale Kriterien werden zumeist eingehalten. Die Fragestellung ist teilweise mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar. Die Wahl des Verfahrens wird begründet, aber die Begründung ist nicht überzeugend. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. ab 4.0 Formale Kriterien werden zumeist eingehalten. Die Fragestellung ist teilweise mithilfe der gewählten Preprocessing- und Analyseverfahren beantwortbar. Die Wahl des Verfahrens wird nicht begründet. Fremder Code wird immer zitiert. Der Code produziert keine Fehlermeldungen. 5.0 Formale Kriterien werden nicht eingehalten. Der Code ist nicht ausführbar und enthält schwerwiegende Fehler. Die Fragestellung ist nicht sinnvoll gewählt und die gewählten Preprocessing- und Analyseverfahren sind nicht geeignet, um die Fragestellung zu bearbeiten. "],["hilfe.html", "Hilfe!!", " Hilfe!! Oft kommt es beim Coden zu komischen Fehlermeldungen, die mehr verwirren als helfen. Häufig steckt aber ein ganz simpler Flüchtigkeitsfehler dahinter. In diesem Fall gilt: 1. Syntax und Rechtschreibung überprüfen. Fehlt vielleicht nur eine Klammer? Ist die Variable wirklich richtig geschrieben? Sind wirklich alle notwendigen Pakete installiert und geladen? 2. Fehlermeldung kopieren und googeln. Bestimmt hatte schonmal jemand anderes dasselbe Problem und bestenfalls findet sich eine Lösung auf https://stackoverflow.com/ oder in einem anderen Forum. 3. ChatGPT fragen. Das Codesnippet an ChatGPT senden und nach möglichen Fehlern fragen. 4. R Hilfeseiten aufrufen. Mit dem ? und dem ?? Operator können über die Konsole die Dokumentation zu konkreten Funktionen aufgerufen werden. Das kann nützlich sein, um beispielsweise zu überprüfen, welchen Datentyp die Funktion als Input nimmt. Weitere Informationen zu den R Hilfeseiten: https://www.r-project.org/help.html Manchmal macht das Skript aber auch einfach nicht das, was es soll, ohne, dass eine Fehlermeldung entsteht. In diesem Fall liegt wahrscheinlich ein logischer Fehler im Programmablauf vor. Für diesen Fall gibt es eine Strategie, die Rubber Ducking oder Quietscheentchen-Debugging genannt wird. 5. Rubber Ducking oder Quietscheentschen-Debugging. Wenn nichts mehr hilft, hilft nur eins: Den Code einer Person, die nichts davon versteht - oder eben einem Quietscheentchen, Zeile für Zeile erklären. Dabei fallen oft logische Fehler auf, die das Problem verursachen. 6. Hilfe holen. Falls ihr im Laufe des Seminars ein Problem habt, das ihr selbst nicht lösen könnt, könnt ihr einen Screenshot für die nächste Sitzung mitbringen oder mir eine E-Mail an l.poggel@fu-berlin.de schreiben. Falls die Konsole (Fenster Console im RStudio) plötzlich + statt &gt; anzeigt oder sich ein Prozess durch Klick auf das rote “Stop”-Symbol nicht abbrechen lässt: Tastenkombination Ctrl (Control) + C (bzw. Strg + C). Zuletzt kann es natürlich auch vorkommen, dass euch ein Inhalt aus dem Seminar nicht ganz klar ist oder ihr ein weiterführendes Interesse an einem Thema habt. Zum Nachlesen empfehle ich die folgenden Lehrbücher und Ressourcen: Allgemein: Offizielle R Handbücher: https://cran.r-project.org/manuals.html Wickham, Hadley, Çetinkaya-Rundel, Mine und Grolemund, Garrett (2023). R for Data Science (=Official Tidyverse Book): https://r4ds.hadley.nz/ Schmidt, Ben (ongoing). Humanities Data Fundamentals: https://hdf.benschmidt.org/R/ Van Atteveldt, Wouter, Trilling, Damian und Arcila Calderón, Carlos (2022). Computational Analysis of Communication: https://cssbook.net/ Stoltz, Dustin S. und Taylor, Marshall A. (2024). Mapping Texts. Computational Text Analysis for the Social Sciences, https://global.oup.com/academic/product/mapping-texts-9780197756881 Sammlung von R “Cheatsheets”: https://github.com/rstudio/cheatsheets/tree/main Lehrbuch-Klassiker (für Grundlagen, bei speziellen Anwendungen zum Teil nicht mehr aktuell): Jockers, Matthew und Thalken, Rosamond (2020). Text Analysis with R for Students of Literature: https://doi.org/10.1007/978-3-030-39643-5 Levshina, Natalia (2015). How to Do Linguistics with R: https://doi.org/10.1075/z.195 Arnold, Taylor und Tilton, Lauren (2015, Neuauflage kommt 2023). Humanities Data in R: https://doi.org/10.1007/978-3-319-20702-5 Desagulier, Guillaume (2017). Corpus Linguistics and Statistics with R: https://doi.org/10.1007/978-3-319-64572-8 Textanalyse mit Quanteda: Offizielle Quanteda-Dokumentationsseiten: https://quanteda.io/ Offizielles Quanteda-Tutorial: https://tutorials.quanteda.io/ Replikation des Codes aus Levshinas “Text Analysis with R for Students of Literature” mithilfe von Quanteda: https://quanteda.io/articles/pkgdown/replication/digital-humanities.html Video-Tutorial zu Preprocessing und Textanalyse mit R von Kasper Welbers: https://www.youtube.com/playlist?list=PL-i7GM-A1wBZYRYTpem7hNVHK3hSV_1It Kapitel 10: “Text as Data” aus “Computational Analysis of Communication”: https://cssbook.net/content/chapter10.html Kapitel 6: “From Text to Numbers” aus “Mapping Texts”: https://global.oup.com/academic/product/mapping-texts-9780197756881 Datenvisualisierung mit ggplot2: Healy, Kieran (2019). Data Visualization. A Practical Introduction, https://socviz.co/ Statistik: (grundlegend) Handl, Andreas und Kuhlenkasper, Torben (2018). Einführung in die Statistik. Theorie und Praxis mit R: https://doi.org/10.1007/978-3-662-56440-0 (grundlegend) Gries, Stefan (2021). Statistics for Linguistics with R: https://doi.org/10.1515/9783110718256 (fortgeschritten) Kroonenberg, Pieter (2021). Multivariate Humanities: https://doi.org/10.1007/978-3-030-69150-9 Hintergrund Preprocessing und Natural Language Processing (POS Tagging, Dependency Parsing, NER,…): Jurafsky, Daniel und Martin, James H. (2023). Speech and Language Processing, https://web.stanford.edu/~jurafsky/slp3/ (insbesondere Kapitel 2, 8, 17, 18). Grimmer, Justin, Roberts, Margaret E. und Stewart, Brandon M. (2022), Text as Data. A New Framework for Machine Learning and the Social Sciences, https://fu-berlin.primo.exlibrisgroup.com/permalink/49KOBV_FUB/1v1tp5h/alma9960725495502883 Biemann, Chris, Heyer, Gerhard und Quasthoff, Uwe (2013). Wissensrohstoff Text. Eine Einführung in das Text Mining, https://doi.org/10.1007/978-3-658-35969-0 (insbesondere Kapitel 1, 2). Theorie: (kommt noch) "],["installation-und-setup.html", "Installation und Setup", " Installation und Setup Egal, welches Betriebssystem: Erst R installieren, dann RStudio! R installieren (Mac: Intel oder Silicon!) https://cran.r-project.org/ Mac: Zusätzlich XQuartz installieren: https://www.xquartz.org/ RStudio installieren (RStudio ist jetzt Posit): https://posit.co/download/rstudio-desktop/ Wenn alles installiert ist, öffnet RStudio. "],["orientierung-im-rstudio.html", "Orientierung im RStudio", " Orientierung im RStudio "],["r-basics-i-datentypen-variablen-und-operatoren.html", "1 R Basics I: Datentypen, Variablen und Operatoren 1.1 Grundlegende Begriffe 1.2 Style Guide 1.3 Kommentare 1.4 Datentypen 1.5 Operatoren 1.6 Variablen 1.7 Operatorpräzedenz Quellen", " 1 R Basics I: Datentypen, Variablen und Operatoren 1.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Objekt Object Alles: Funktionen, Variablen, Datenstrukturen,.. Anweisung Statement Syntaktische Einheit, die Aktionen beschreibt, die von einem Computer ausgeführt werden können. Wenn die Anweisung ausgeführt wird, wird die Aktion veranlasst und der Zustand des Speichers wird geändert. Zuweisung Assignment Besondere Art von Anweisung, bei der einer Variable ein bestimmter Wert zugeordnet wird. Dabei wird ein Name festgelegt, der fortan für diesen Wert und für den Speicherplatz, in dem der Wert gespeichert wird, steht. Ausdruck Expression Syntaktische Einheit, die zu einem Wert evaluiert (ausgewertet) werden kann. Ein Ausdruck ist immer Teil einer Anweisung. Ausdrücke stehen auf der rechten Seite von Zuweisungen: x &lt;- Ausdruck. Ausdrücke haben immer einen Typ, der dem Datentyp des Werts entspricht, zu dem sie evaluiert werden, z.B. 3 == 4 ist ein Ausdruck vom Typ boolean. Aussage Proposition In der Aussagenlogik ein sprachliches Gebilde, von dem es sinnvoll ist zu sagen, dass es entweder wahr oder falsch ist (Aristoteles). Im R-Kontext ein Ausdruck, der entweder zu TRUE oder zu FALSE evaluiert werden kann. Auswerten Evaluate Der Computer liest einen Ausdruck und wertet diesen aus: Er berechnet etwas und liefert einen Wert. Ausführen Execute Der Computer liest eine Anweisung und führt diese aus: Er macht etwas und ändert den Zustand des Speichers. Ausgeben Output/Print Das Ergebnis einer Berechnung oder die Ausgabe einer Funktion wird auf der Konsole angezeigt. Die Definitionen sind angelehnt an Venables et al. (2023), Wickham (2019) und Reussner (2016). 1.2 Style Guide Anders als beispielsweise in Python gibt es in R keinen allgemein anerkannten “Coding Style”, also keine über die Syntaxregeln hinausgehenden Vorgaben, wie Code am besten geschrieben wird. Es gibt allerdings einige breit akzeptierte Empfehlungen. Wir richten uns in diesem Kurs nach dem “Tidyverse Style Guide” von Hadley Wickham: https://style.tidyverse.org/. 1.3 Kommentare Um den eigenen Code für andere verständlicher zu gestalten und sich selbst an seinen Code zu erinnern, sollte man diesen immer gut kommentieren. # Das ist ein Kommentar 1.4 Datentypen In R ist ganz grundsätzlich alles ein Objekt: ein Wort, eine Zahl, ein Vektor, eine Liste, eine Variable und sogar Funktionen (lernen wir alles später), all das wird in R als Objekt behandelt. Wie auch in der realen Welt haben verschiedene Objekte verschiedene Eigenschaften und sie können für verschiedene Zwecke und auf verschiedene Weise verwendet werden. Das hängt davon ab, um was für eine Art Objekt es sich handelt: ein Objekt vom Typ “Lampe” kann man anschalten und ausschalten, mathematische Objekte wie Zahlen kann man addieren und dividieren, ein Auto kann fahren, parken oder tanken. In R haben wir es natürlich nicht mit realen Objekten zu tun, sondern eigentlich mit “Datenobjekten”. In R gibt es vier grundlegende Datentypen (und zwei, die wir jetzt erstmal ignorieren): character (auch “character string”): Zeichenkette integer: Ganzzahl numeric (auch “double”): Gleitkommazahl logical (auch “boolean”): Boolescher Wahrheitswert Character ist kurz für “character string”; in anderen Programmiersprachen heißt dieser Datentyp daher oft “string”. In R wird jeder Ausdruck, der von Anführungszeichen umgeben ist, als Zeichenkette (character) interpretiert. Double ist, ähnlich wie bei character und string, der allgemeine Name für den Datentyp numeric. Der Default-Datentyp für Zahlen ist in R numeric. Um eine Zahl als Integer zu definieren, kann ein großes L an die Zahl angefügt werden. Logical steht für die beiden Werte TRUE und FALSE. Sie werden auch als Boolesche Wahrheitswerte bezeichnet (-&gt; kennt ihr ggf. aus der Aussagenlogik). Für “Datentyp” kann man auch kurz “Typ” sagen. Ein paar Beispiele: 2 2L 345682389 4.6 # Punkt statt Komma! &quot;4.6&quot; TRUE FALSE &quot;Hello World&quot; # Anführungszeichen! &quot;Ein ganz langer Satz! Mit mehreren Satzzeichen. Und einer Zahl: 34.&quot; &quot; &quot; Den Datentyp eines Objekts könnt ihr z.B. mit der Funktion typeof() abfragen. Wenn ihr jede Zeile nacheinander in ein R Skript kopiert und ausführt, wird auf der Konsole (Fenster Console im RStudio) der Wert ausgegeben, der hier von #&gt; angeführt wird. typeof(2) #&gt; [1] &quot;double&quot; typeof(2L) #&gt; [1] &quot;integer&quot; typeof(4.6) #&gt; [1] &quot;double&quot; typeof(&quot;Hello World&quot;) #&gt; [1] &quot;character&quot; typeof(TRUE) #&gt; [1] &quot;logical&quot; Verständnisfragen: Ist ” ” auch ein Zeichen? Haben 4.6 und “4.6” denselben Datentyp? Welchen Datentyp hat der Satz “Ein ganz langer Satz! …”? Style Tip: Für Zeichenketten können einfache oder doppelte Anführungszeichen verwendet werden. Wickham empfiehlt, für Zeichenketten doppelte Anführungszeichen zu verwenden, außer, wenn diese selbst Anführungszeichen beinhalten, hier werden beide Anführungszeichen wie folgt kombiniert: ‘Text mit “Anführungszeichen”’. 1.5 Operatoren Je nachdem, welchen Datentyp ein oder mehrere Objekte in R haben, können diese Objekte auf verschiedene Weise mithilfe von Operatoren manipuliert werden. Arithmetische Operatoren sind aus der Schulmathematik bekannt. Es handelt sich dabei um Operatoren wie -, +, *, / sowie %% und %/%. Beachtet, dass der Divisionsoperator / nur für numerics definiert ist. Für die Division zweier integers wird ein spezieller Divisionsoperator, %/%, verwendet. %% ist der modulo Operator, damit kann bei einer Division der Rest berechnet werden. ^ oder ** wird zum Exponieren verwendet. 5+4 #&gt; [1] 9 10/5 #&gt; [1] 2 10%%5 #&gt; [1] 0 10^2 #&gt; [1] 100 10**2 #&gt; [1] 100 Verständnisfragen: Was passiert, wenn wir \"Hallo\" + \"Welt\" ausführen? Welche Datentypen in R erlauben arithmetische Operationen? Logische Operatoren ermöglichen es, Werte zu vergleichen und die Richtigkeit einer logischen Aussage zu überpüfen. Die Vergleichsoperatoren &lt;, &gt;, &lt;=, &gt;= sind allgemein bekannt. Außerdem sind folgende Operatoren wichtig: Operator Bedeutung == genau gleich != ungleich !x nicht x x ⎮ y x oder y x &amp; y x und y x ⎮⎮ y x oder y in Kontrollstrukturen x &amp;&amp; y x und y Kontrollstrukturen Beispiele: -5 &lt; -10 #&gt; [1] FALSE 5 &gt;= 5 #&gt; [1] TRUE 3 != 5 #&gt; [1] TRUE &quot;Hallo&quot; != &quot;Hello&quot; #&gt; [1] TRUE 3 == 3 &amp; &quot;c&quot; == &quot;c&quot; #&gt; [1] TRUE 3 == 3 | &quot;c&quot; == &quot;a&quot; #&gt; [1] TRUE &quot;Eine Rose ist eine Pflanze&quot; == &quot;Eine Rose ist keine Pflanze&quot; #&gt; [1] FALSE Verständnisfragen: Warum wird der Ausdruck 3 == 3 &amp; \"c\" == \"c\" zu TRUE evaluiert? Warum wird auch der Ausdruck 3 == 3 | \"c\" == \"a\" zu TRUE evaluiert? Was passiert im letzten Beispiel? Der Wahrheitswert, zu dem ein Ausdruck mit einem logischen Operator in R evaluiert wird, lässt sich aus einer sogenannten Wahrheitstabelle ablesen. Für zwei Ausdrücke A und B und die logischen Operatoren &amp; und | lassen sich die folgenden Kombinationen als Wahrheitstabelle darstellen: Verständnisfragen: A sei der Ausdruck 3 == 3 &amp; \"c\" == \"c\" und B sei der Ausdruck -5 &lt; -10. Ist A &amp; B wahr oder falsch? Ist A | B wahr oder falsch? In Kontrollstrukturen (lernen wir noch) werden anstelle von &amp; und | die beiden Operatoren &amp;&amp; und || verwendet. Das hat den Grund, dass die Objekte in einem Ausdruck mit &amp;und | bei “elementweise” ausgewertet werden. Bei der Auswertung von Ausdrücken mit &amp;&amp; und || wird dagegen nur das erste Element ausgewertet. Dieses Verhalten heißt deswegen auch “lazy evaluation”. Das Verhalten ist bei einfachen Ausdrücken nicht bemerkbar, aber es wird relevant, wenn die Operatoren auf Datenstrukturen anstelle von einzelnen Werten wie bisher angewendet werden. Für die beiden Operatoren &amp;&amp; und || sind die Wahrheitstabellen also nur dann zu den Wahrheitstabellen der Operatoren &amp; und | analog, wenn einzelne Werte verglichen werden. Darauf werden wir in der kommenden Stunde noch einmal zurückkommen, wenn wir Objekte kennengelernt haben, die aus mehreren Elementen bestehen. Im nächsten Abschnitt werden wir einen weiteren Operator kennenlernen, den sogenannten Zuweisungsoperator &lt;- bzw. =. Daneben gibt es die Zugriffsoperatoren [], [[]], [:] und $, mit denen Operationen auf Datenstrukturen ausgeführt werden können. Diese Operatoren lernen wir in der nächsten Stunde kennen, wenn wir uns mit Datenstrukturen beschäftigen. 1.6 Variablen Angenommen, wir wollen den Wert, der ausgegeben wird, wenn der Ausdruck 3 == 3 &amp; \"c\" == \"c\" evaluiert wird, im Programmverlauf noch einmal verwenden. Dann wäre es unpraktisch, wenn wir jedes Mal den gesamten Ausdruck kopieren müssten. Wenn wir später die 3 durch eine 4 ersetzen, müssten wir dann alle Stellen finden, wo derselbe Ausdruck vorkommt, und überall die Änderung vornehmen. So entstehen schnell Fehler. Aus diesem Grund gibt es Variablen. Variablen ermöglichen, einen bestimmten Wert im Verlauf des Programms mehrmals zu verwenden, ohne ihn jedes Mal neu berechnen oder eingeben zu müssen. Werte können mithilfe der Zuweisungsoperatoren &lt;- und = einer Variable “zugewiesen” werden. Das heißt, dass ein Name festgelegt wird, der fortan für diesen Wert und für den Speicherplatz, in dem der Wert gespeichert wird, steht. Man kann alternativ auch sagen, dass ein Wert “an einen Namen gebunden” wird, oder andersherum, dass der Name einen bestimmten Wert “referenziert”. Eine Zuweisung folgt in R dem Schema Name &lt;- Wert. So kann mithilfe des Variablennamens auf den damit verknüpften Wert zugegriffen werden, selbst dann, wenn sich der Wert im Programmverlauf verändert hat. Variablen sind also sowas wie Platzhalter für Werte eines Datentyps. Bei der Benennung von Variablen sollten bestimmte Regeln und die Konventionen aus unserem Style Guide eingehalten werden: Variablennamen dürfen kein Leerzeichen enthalten (Regel!). Variablennamen dürfen keine Sonderzeichen außer Punkte und Unterstriche enthalten (Regel!). Zwei Wörter oder ein Wort und eine Zahl können mit Unterstrich, Punkt, oder camelCase getrennt werden. Wickhams Empfehlung ist hier die Verwendung des Unterstrichs. Variablen dürfen nicht mit einer Zahl oder einem Unterstrich anfangen (Regel!). R ist “case sensitive”, das heißt: die Variable baum ist nicht dasselbe wie die Variable Baum! Mit dem Zuweisungsoperator &lt;- bzw. = kann ein Wert einem Namen zugewiesen werden. &lt;- und = sind gleichbedeutend; Wickham empfiehlt aber die Verwendung des Operators &lt;-. Beim Ausführen einer Zuweisung wird nichts auf dem Bildschirm (auf der Rstudio Konsole) ausgegeben. Nach der Zuweisung können Werte, die einer Variable zugeordnet sind, mithilfe der Funktion print() auf dem Bildschirm ausgegeben werden. Alternativ kann auch einfach der Variablennamen erneut eingegeben und ausgeführt werden. # Zuweisungen zahl &lt;- 454 satz &lt;- &quot;Eine Rose ist eine Pflanze&quot; satz_2 &lt;- &quot;Eine zweite Rose ist auch eine Pflanze&quot; noch_ein_satz &lt;- &quot;Noch eine Rose&quot; Satz &lt;- &quot;Eine Rose ist keine Pflanze&quot; # Variable Satz auf dem Bildschirm ausgeben print(Satz) #&gt; [1] &quot;Eine Rose ist keine Pflanze&quot; # Variable satz auf dem Bildschirm ausgeben print(satz) #&gt; [1] &quot;Eine Rose ist eine Pflanze&quot; # Variable satz ohne die print()-Funktion auf dem Bildschirm ausgeben satz #&gt; [1] &quot;Eine Rose ist eine Pflanze&quot; # Der Variable satz einen neuen Wert zuweisen satz &lt;- &quot;Ein Apfel ist keine Pflanze&quot; # Variable satz erneut ausgeben print(satz) #&gt; [1] &quot;Ein Apfel ist keine Pflanze&quot; # hier werden die Variablen satz und Satz aus dem Beispiel oben verglichen satz == Satz #&gt; [1] FALSE Verständnisfragen: Welchen Datentyp hat die Variable zahl? Warum wird das erste Mal, dass die Anweisung print(satz) ausgeführt wird, ein anderer Wert ausgegeben, als beim zweiten Mal? Warum wird der Ausdruck satz == Satz zu FALSE evaluiert? Warum ist es nicht korrekt zu sagen, dass bei der Zuweisung ein Wert in einer Variable gespeichert wird? Wie könn die Ausdrücke 1 &gt; 2 &amp; 1 &lt; 4, 1 &gt; 2 &amp;&amp; 1 &lt; 4 und 1 == 1 &amp;&amp; 1 &lt; 4 mithilfe von Variablen so umgeschrieben werden, dass sich die Zahl 1 nicht wiederholt? Was passiert, wenn 23 -&gt; zahl ausgeführt wird? Nicht nur einzelne Werte können Variablen zugewiesen werden, sondern auch ganze Ausdrücke. In der nächsten Stunde werden wir außerdem sehen, dass auch Datenstrukturen Variablen zugewiesen werden können. # Ausdrücke als Variablen aussage_1 &lt;- &quot;c&quot; == &quot;c&quot; aussage_2 &lt;- 3 == 5 aussage_1 == !aussage_2 #&gt; [1] TRUE Verständnisfragen: Was passiert in diesem Beispiel? Welcher Wert wird den Variablen aussage_1 und aussage_2 zugewiesen? Gut zu wissen: Eine Zuweisung ist eine Art von Anweisung: Sie beschreibt eine bestimmte Aktion, die vom Computer ausgeführt wird und die den Zustand des Speichers ändert. Deswegen sagt man, dass Anweisungen ausgeführt werden, während Ausdrücke ausgewertet werden. 1.7 Operatorpräzedenz Wir haben bereits einige Beispiele für Ausdrücke kennengelernt, die mehrere Operatoren beinhalten. Wie auch bei arithmetischen Operatoren gibt es bei allen anderen Operatoren eine festgelegte Reihenfolge, in der diese Operatoren ausgewertet werden, wenn sie im selben Ausdruck vorkommen und sich einen Operanden teilen. Für die bisher bekannten Operatoren gilt die folgende Rangfolge: Rang Operator 1 $ 2 [], [[]] 3 ^ 4 [:] 5 *, / 6 +, - 7 &lt;, &gt;, &lt;=, &gt;=, ==, != 8 ! 9 &amp;, &amp;&amp; 10 ⎮, ⎮⎮ 11 &lt;- Wenn diese Auswertungsreihenfolge geändert werden soll, müssen runde Klammern verwendet werden. Beispiele: 4+10 &gt; 3+5*2 #&gt; [1] TRUE 4+10 &gt; (3+5)*2 #&gt; [1] FALSE FALSE &amp; TRUE == FALSE #&gt; [1] FALSE (FALSE &amp; TRUE) == FALSE #&gt; [1] TRUE Wenn zwei Operatoren in einem Ausdruck denselben Rang haben und einen Operanden teilen, wird der Ausdruck nach der sogenannten Assoziativität der Operatoren ausgewertet: wenn ein Operator linksassoziativ ist, dann heißt dass, dass ein Ausdruck von links nach rechts ausgewertet wird. Wenn ein Operator rechtsassoziativ ist, wird ein Ausdruck von rechts nach links ausgewertet. In R sind fast alle Operatoren linksassoziativ; nur der Potenzierungsoperator und der Zuweisungsoperartor sind rechtsassoziativ. Linksassoziatitvität: ((4+5)+6)+1 = (9+6)+1 = 15+1 = 16 Rechtsassoziativität: 3**(4**5) = 3**1024 = eine sehr lange Zahl Quellen Venables, W.N. and Smith, D.M. and the R Core Team (2023). An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Wickham, Hadley (2019). Advanced R. Chapter 2: Names and Values, https://adv-r.hadley.nz/names-values.html Reussner, Ralf H. Mitschnitt zur Vorlesung “Programmieren” im WiSe 2015/2016. 02: Typen und Variablen, https://www.youtube.com/watch?v=POe41EL2EgU R 4.3.0 Documentation. Operator Syntax and Precedence, https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html Wickham, Hadley (2019). Advanced R. Chapter 4: Subsetting, https://adv-r.hadley.nz/subsetting.html "],["r-basics-ii-datenstrukturen.html", "2 R Basics II: Datenstrukturen 2.1 Grundlegende Begriffe 2.2 Vektoren 2.3 Listen 2.4 Auf einen Blick: Vektoren vs benannte Vektoren vs Faktoren vs Listen 2.5 Matrizen 2.6 Arrays 2.7 Dataframes 2.8 Auf einen Blick: Matrizen vs Arrays vs Dataframes 2.9 Fehlende und ungültige Werte in Datenstrukturen 2.10 Der Mitgliedschaftsoperator %in% 2.11 Unveränderbarkeit von Objekten in R Quellen", " 2 R Basics II: Datenstrukturen Bisher haben wir Variablen als Platzhalter für Werte vom Typ character, integer, numeric oder logical genutzt. Variablen können aber auch Platzhalter für strukturierte Sammlungen von Werten sein. Die verschiedenen Weisen, wie Daten in R organisiert und im Speicher repräsentiert werden können, werden Datenstrukturen genannt. Solche Datenstrukturen können entweder nur Elemente vom selben Typ aufnehmen (wie z.B. Vektoren und Matrizen), oder Elemente unterschiedlichen Typs (wie z.B. Listen und Dataframes). Wir werden in diesem Kapitel alle wichtigsten Datenstrukturen besprechen. In der Praxis werden wir aber vor allem mit Vektoren und Dataframes arbeiten. 2.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Element Element Wert oder anderes Objekt innnerhalb einer Datenstruktur. Datenstrukturen können selbst Elemente einer anderen Datenstruktur sein. Elemente haben einen Index und manchmal zusätzlich einen Namen (oder ‘Schlüssel’), über den auf das Element zugegriffen werden kann. Index Index Position eines Elements innerhalb einer Datenstruktur. Ein Index ist in R immer eine Zahl &gt;= 1. Indexierung Indexing Überbegriff für verschiedene Operationen, mit denen auf Elemente in einer Datenstruktur zugegriffen werden kann. Zugreifen Access Operation, bei der durch den Einsatz spezifischer Operatoren Elemente einer Datenstruktur ausgewählt, diese extrahiert oder modifiziert werden können. Vektorisierung Vectorization Mechanismus, bei dem Funktionen oder Operationen automatisch auf alle Elemente eines Vektors angewandt werden, statt auf einzelne Elemente. Dimension Dimension In Bezug auf Matrizen die Anzahl von Zeilen und Spalten (angegeben als Zeilen x Spalten). In Bezug auf Arrays allgemein die Anzahl der verschiedenen ‘Richtungen’, in denen Daten organisiert sind. Bei einem Array können das nicht nur Zeilen und Spalten sein, sondern auch ‘Schichten’ von Matrizen und andere Organisationsweisen. 2.2 Vektoren Eigentlich haben wir in der letzten Stunde schon Vektoren kennengelernt. Denn in R ist jeder einzelne Wert zugleich ein Vektor der Länge 1. Vektoren sind nämlich im Grunde Sequenzen verschiedener Werte desselben Datentyps. Die Werte innerhalb eines Vektors werden Elemente genannt. Jedes Element in einem Vektor hat eine Position (auch “Index” genannt). Über diesen Index kann auf jedes Element einzeln zugegriffen werden. Der Zugriff auf Elemente des Vektors erfolgt mithilfe von eckigen Klammern (s.u.). Vektoren können mithilfe von bestimmten Funktionen (lernen wir noch) erstellt werden. Wenn bei der Erstellung bekannt ist,welchen Datentyp die Elemente haben sollen, können die Funktionen character() oder numeric() zur Erstellung verwendet werden: # leeren character-Vektor erstellen: character(0) bedeutet, dass der Vektor keine Elemente hat character() #&gt; character(0) # numeric-Vektor mit drei Elementen vom Typ numeric erstellen numeric(3) #&gt; [1] 0 0 0 Im Regelfall ist aber die Anzahl der Elemente und/oder deren Datentyp bei der Erstellung noch nicht bekannt. In diesem Fall wird zur Erstellung die Funktion c() verwendet: # leeren Vektor erstellen, ohne einen bestimmten Datentyp festzulegen c() #&gt; NULL Wenn ein leerer Vektor erstellt wird, wird dieser mithilfe des Werts NULL repräsentiert. Darauf kommen wir am Ende der Sitzung noch einmal zurück. Mithilfe der Funktion c() können auch Vektoren aus bereits bekannten Elementen erstellt werden: # Vektor aus einer Zahlsequenz erstellen zahlen &lt;- 1:3 print(zahlen) #&gt; [1] 1 2 3 # Vektoren mit selbst gewählten Elementen erstellen leckere_fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;) coole_zahlen &lt;- c(45, 7, 420) Vektoren können auch in einen neuen Vektor zusammengefügt werden. Wenn die Funktion c() auf zwei Vektoren oder einen Vektor und ein Element angewandt wird, dann werden die beiden Vektoren in der angegebenen Reihenfolge in einen neuen Vektor kombiniert: # Vektoren kombinieren mithilfe der Funktion c() fruechte_und_zahlen &lt;- c(leckere_fruechte, coole_zahlen) # Vektor auf dem Bildschirm ausgeben print(fruechte_und_zahlen) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;45&quot; &quot;7&quot; &quot;420&quot; Bei der Erstellung von Vektoren muss beachtet werden, dass der Typ der Elemente automatisch vereinhetilicht wird, wenn Elemente mit unterschiedlichen Datentypen in einen Vektor kombiniert werden: vec &lt;- c(&quot;hallo&quot;, &quot;1&quot;) vec &lt;- c(vec, 3) # double wird zu character typeof(vec) #&gt; [1] &quot;character&quot; # bool wird zu double vec &lt;- c(3, TRUE) typeof(vec) #&gt; [1] &quot;double&quot; Nur, wenn ein Element des Vektors eine Liste ist, gilt dieses Prinzip nicht. Darauf kommen wir im Abschnitt “Listen” noch einmal zurück. 2.2.1 Sets (Mengen) In anderen Programmiersprachen (bspw. Python) gibt es eine Datenstruktur, die oft Set (Menge) genannt wird. Sets (Mengen) sind dadurch ausgezeichnet, dass alle Werte einzigartig sind. In R gibt es keine eigenständige Datenstruktur für Mengen. Dennoch ist es möglich und oft nützlich, in R mit Sammlungen von einzigartigen Werten zu arbeiten und Mengenoperationen durchzuführen. In R können Mengen aus Vektoren erstellt werden, indem die einzigartigen Werte eines Vektors oder mehrerer Vektoren extrahiert werden: # Einzigartige Werte eines Vektors ausgeben lassen unique(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; # Vereinigung von zwei Vektoren: union(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;), c(&quot;Kiwi&quot;, &quot;Grapefruit&quot;)) #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;Kiwi&quot; &quot;Grapefruit&quot; # Schnittmenge von zwei Vektoren: intersect(c(&quot;Apfel&quot;, &quot;Banane&quot;), c(&quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Apfel&quot; # Differenz zwischen zwei Vektoren: Elemente erhalten, die im ersten Vektor, aber nicht im zweiten Vektor vorkommen. setdiff(c(&quot;Apfel&quot;, &quot;Banane&quot;), c(&quot;Erdbeere&quot;, &quot;Apfel&quot;)) #&gt; [1] &quot;Banane&quot; Die Funktion unique() kann mit der Funktion length() kombiniert werden, um herauszufinden, wie viele einzigartige Werte es in einem Vektor gibt: length(unique(c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;))) #&gt; [1] 3 2.2.2 Named Vectors Neben den “einfachen” Vektoren gibt es noch sogenannte benannte Vektoren oder named vectors. Das sind Vektoren, bei dem jedem Element nicht nur eine Indexposition, sondern auch ein Name zugeordnet ist. Um einen named vector zu erstellen, wird ebenfalls die Funktion c() verwendet. Den Elementen wird bei der Erstellung des Vektors aber ein Name (oder “Schlüssel”) zugeordnet. Dieser muss ein character sein. Beachtet, dass bei der Zuweisung von Namen innerhalb von Funktionen anstelle des Zuweisungsoperators &lt;- der Operator = verwendet wird: # Erstellung eines named vectors: Schlüssel sind immer Zeichenketten einkauf &lt;- c(&quot;Apfel&quot;=4, &quot;Banane&quot;=3, &quot;Erdbeere&quot;=20) # ...selbst dann, wenn ihr Wörter ohne Anführungszeichen eingebt, weiß R, dass eine Zeichenkette gemeint ist: einkauf &lt;- c(Apfel=4, Banane=3, Erdbeere=20) # Das geht allerdings nicht, wenn ihr Zahlen als Schlüssel eingebt! # einkauf &lt;- c(1=4, 2=3, 3=20) 2.2.3 Faktoren Da R ursprünglich für die Statistik entwickelt wurde, haben sich die Entwickler:innen der Programmiersprache überlegt, dass es praktisch wäre, wenn es eine Datenstruktur speziell für kategorische (auch “kategoriale”) Daten gäbe. Kategorische Daten sind Daten, die in bestimmte Kategorien oder Gruppen fallen, also beispielsweise Farben, Regionen, Beschäftigungsstatus. Speziell zur Organisation solcher Daten gibt es in R Faktoren. Ein Faktor ist eine spezielle Art von Vektor, der kategorische Daten repräsentiert. Faktoren werden mithilfe der Funktion factor() erstellt. Faktoren werden stets aus bereits existierenden Vektoren erstellt, beispielsweise aus dem named vector named_vec und aus einem Vektor vec, den wir neu erstellen: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;) factor(fruechte) #&gt; [1] Apfel Banane Erdbeere Apfel #&gt; Levels: Apfel Banane Erdbeere Wann würde man also Faktoren verwenden? Wenn man nur die einzigartigen Werte braucht, dann kann einfach die Funktion unique() auf einen “einfachen” Vektor angewandt werden und braucht keine Faktoren (s. “Sets”). Aber wenn man herausfinden möchte, wie oft jeder Wert jeweils vorkommt, dann ist das mithilfe der unique() Funktion kompliziert: # Diesen Code müsst ihr nicht verstehen, er dient nur, um die Komplexität zu illustrieren haeufigkeiten &lt;- sapply(unique(fruechte), function(x) sum(fruechte == x)) haeufigkeiten #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Mithilfe von Faktoren können wir viel einfacher herausfinden, wie oft jeder Wert vorkommt, und zwar mithilfe der Funktion table(). Sie erlaubt, die Anzahl der einzigartigen Werte ausgeben zu lassen: table(factor(fruechte)) #&gt; #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Tatsächlich wandelt die Funktion table() automatisch den Vektor in einen Faktor um, wenn das Argument kein Faktor ist. Wenn wir herausfinden wollen, wie oft jeder Wert in einem Vektor vorkommt, dann brauchen wir also nicht unbedingt erst den Vektor in einen Faktor umwandeln. Wir können die table-Funktion direkt auf den Vektor anwenden: table(fruechte) #&gt; fruechte #&gt; Apfel Banane Erdbeere #&gt; 2 1 1 Wie wir gesehen haben, greifen Funktionen wie table() unter der Motorhaube auf dieses Konzept zurück und wandeln einen Vektor automatisch in einen Faktor um. Auch in anderen Kontexten werden Faktoren oft automatisch erstellt. Trotzdem solltet ihr zumindest von Faktoren gehört haben. Denn selbst, wenn wir in der Praxis nicht unbedingt viel mit Faktoren arbeiten werden und selten Faktoren selbst erstellen, spielen Faktoren in R beim Umgang mit kategorialen Daten eine große Rolle und sind zum Verständnis von manchen Funktionen wichtig. 2.2.4 Zugriffsoperationen auf Vektoren Den Zugriff auf ein Element oder mehrere Elemente in einer Datenstruktur nennt man auch Indexierung. Dabei wird mithilfe von einem Zugriffsoperator über den Index oder den Namen (Schlüssel) eines Elements zugegriffen. Als Beispiel für den Zugriff über den Index sehen wir uns einige Zugriffsoperationen auf den Vektor leckere_fruechte an: fruechte &lt;- c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Erdbeere&quot;, &quot;Apfel&quot;) # Zugriff auf das erste Element des Vektors leckere_fruechte über den Index fruechte[1] #&gt; [1] &quot;Apfel&quot; # Zugriff auf Elemente 1-3 fruechte[1:3] #&gt; [1] &quot;Apfel&quot; &quot;Banane&quot; &quot;Erdbeere&quot; # Zugriff auf Elemente 1 und 3 fruechte[c(1,3)] #&gt; [1] &quot;Apfel&quot; &quot;Erdbeere&quot; # Zugriff auf alle Elemente mit dem Wert &quot;Banane&quot; fruechte[fruechte == &quot;Banane&quot;] #&gt; [1] &quot;Banane&quot; # Element an Indexposition 1 austauschen fruechte[1] &lt;- &quot;Orange&quot; # Neues Element an Indexposition 5 hinzufügen fruechte[5] &lt;- &quot;Birne&quot; # Neues Element am Ende des Vektors hinzufügen fruechte &lt;- c(fruechte, &quot;Melone&quot;) # Neues Element am Anfang des Vektors hinzufügen fruechte &lt;- c(&quot;Traube&quot;, fruechte) # Element an Indexposition 1 entfernen fruechte[-1] #&gt; [1] &quot;Orange&quot; &quot;Banane&quot; &quot;Erdbeere&quot; &quot;Apfel&quot; &quot;Birne&quot; &quot;Melone&quot; Elemente können auch direkt einer neuen Variable zugewiesen werden: erste_frucht &lt;- fruechte[1] print(erste_frucht) #&gt; [1] &quot;Traube&quot; Um auf die Elemente eines named vectors zuzugreifen, kann entweder der Index oder der Name des Elements verwendet werden: einkauf &lt;- c(&quot;Apfel&quot;=4, &quot;Banane&quot;=3, &quot;Erdbeere&quot;=20, &quot;Apfel&quot;=5) # Zugriff auf das Element mit dem Namen &quot;Erdbeere&quot;: Hier müssen die Anführungszeichen wieder explizit angegeben werden (zur Erinnerung: Schlüssel sind immer character!) einkauf[&quot;Erdbeere&quot;] #&gt; Erdbeere #&gt; 20 # Zugriff auf alle Elemente mit dem Namen &quot;Apfel&quot;: einkauf[&quot;Apfel&quot;] #&gt; Apfel #&gt; 4 # Zugriff auf mehrere Elemente einkauf[c(&quot;Apfel&quot;, &quot;Erdbeere&quot;)] #&gt; Apfel Erdbeere #&gt; 4 20 # Wert (!) des Elements mit dem Namen &quot;Banane&quot; austauschen einkauf[&quot;Banane&quot;] &lt;- 5 # Neues Element mit dem Namen &quot;Birne&quot; hinzufügen einkauf[&quot;Birne&quot;] &lt;- 3 # Neues Element am Ende des Vektors hinzufügen einkauf &lt;- c(einkauf, Melone=1) # Neues Element am Anfang des Vektors hinzufügen einkauf &lt;- c(Traube=12, einkauf) # Element mit dem Namen &quot;Birne&quot; entfernen: einkauf &lt;- einkauf[!(names(einkauf) == &quot;Birne&quot;)] einkauf #&gt; Traube Apfel Banane Erdbeere Apfel Melone #&gt; 12 4 5 20 5 1 Verständnisfragen: Wie viele Elemente hat der Vektor fruechte? Wie kann das Element \"Orange\" aus dem Vektor fruechte entfernt werden? An welcher Indexposition steht es jetzt? Sind einzelne Zahlen oder Zeichenketten in R auch Datenstrukturen? Wenn ja, welche? Zu welchem Wahrheitswert wird der Ausdruck c(2) == 2 evaluiert? Warum? Wie kann auf alle Elemente mit dem Wert 3 im Vektor einkauf zugegriffen werden? 2.2.5 Vektorisierung Auf Vektoren können auch die bereits bekannten Operatoren angewendet werden. Wenn Operatoren auf Vektoren angewandt werden, wird die Operation automatisch elementweise auf jedes Element der beiden Operanden angewandt. Dieser Mechanismus nennt sich Vektorisierung. Wir werden in der Sitzung zu Funktionen noch einmal darauf zurückkommen. Wichtig ist dabei zu beachten, dass beide Vektoren die gleiche Länge haben müssen. Auf Vektoren vom Typ numeric oder integer (also Vektoren, deren Elemente alle numerics oder integers sind) können die arithmetischen Operatoren angewandt werden, zum Beispiel: vec_1 &lt;- c(1, 2, 3) vec_2 &lt;- c(3, 5, 6) vec_1 + vec_2 #&gt; [1] 4 7 9 vec_1 / vec_2 #&gt; [1] 0.3333333 0.4000000 0.5000000 Wird ein Vektor nicht mit einem anderen Vektor, sondern mit einem einzelnen Wert addiert (oder subtrahiert, dividiert, … ), dann wird jedes Element des Vektors mit diesem Wert verrechnet: vec_1 + 5 #&gt; [1] 6 7 8 Daneben können auch Vergleichsoperatoren und logische Operatoren auf Vektoren angewandt werden: vec_1 == vec_2 #&gt; [1] FALSE FALSE FALSE vec_1 &lt; vec_2 #&gt; [1] TRUE TRUE TRUE vec_1 &lt; 3 #&gt; [1] TRUE TRUE FALSE In der letzten Sitzung haben wir bereits den Unterschied zwischen dem “elementweisen” Operatoren &amp; und | und den Operatoren &amp;&amp; und || angeschnitten. Das Verhalten war bei der Auswertung einfacher Ausdrücke mit einzelnen Werten nicht bemerkbar, aber es wird relevant, wenn die Operatoren auf Vektoren anstelle von einzelnen Werten angewandt werden: zahlen &lt;- 1:5 zahlen &gt; 2 &amp; zahlen &lt; 4 #&gt; [1] FALSE FALSE TRUE FALSE FALSE zahlen &gt; 2 &amp;&amp; zahlen &lt; 4 #&gt; Error in zahlen &gt; 2 &amp;&amp; zahlen &lt; 4: &#39;length = 5&#39; in coercion to &#39;logical(1)&#39; Verständnisfragen: Warum wird der Ausdruck zahlen &gt; 2 &amp; zahlen &lt; 4 zu FALSE FALSE TRUE FALSE FALSE evaluiert? Welche Datenstruktur wird ausgegeben, wenn der Ausdruck evaluiert wird? Was bedeutet die Fehlermeldung bei der Auswertung des Ausdrucks zahlen &gt; 2 &amp;&amp; zahlen &lt; 4? 2.3 Listen Listen enthalten wie Vektoren eine Sequenz verschiedener Werte. Im Abschnitt zu Vektoren haben wir bereits gelernt, dass diese Werte auch Elemente genannt werden. Anders als bei Vektoren können die Elemente einer Liste aber verschiedene Datentypen haben. Ähnlich wie bei benannten Vektoren kann man den Elementen einer Liste einen Namen (wird manchmal auch Schlüssel genannt) zuordnen, über den auf den Wert zugegriffen werden kann. Listen werden mithilfe der Funktion list() erstellt. Genau wie bei benannten Vektoren (named vectors) müssen die Schlüssel der Werte Zeichenketten sein. Wenn keine Anführungszeichen angegeben werden, erkennt R auch hier automatisch, dass eine Zeichenkette gemeint ist. # Liste erstellen hanna &lt;- list(Name=&quot;Hanna&quot;, Alter=14, Haustier=&quot;Hund&quot;) # Liste ausgeben print(hanna) #&gt; $Name #&gt; [1] &quot;Hanna&quot; #&gt; #&gt; $Alter #&gt; [1] 14 #&gt; #&gt; $Haustier #&gt; [1] &quot;Hund&quot; Die Elemente einer Liste können auch Vektoren oder selbst Listen sein. Im letzteren Fall wird die Liste dann “Liste von Listen” oder “verschachtelte Liste” genannt: # Liste von Vektoren erstellen: liste_von_vektoren &lt;- list(Namen = c(&quot;Hanna&quot;, &quot;James&quot;, &quot;Lin&quot;), Alter = c(14, 19, 20), Haustier = c(&quot;Hund&quot;, &quot;Katze&quot;, &quot;Hund&quot;) ) print(liste_von_vektoren) #&gt; $Namen #&gt; [1] &quot;Hanna&quot; &quot;James&quot; &quot;Lin&quot; #&gt; #&gt; $Alter #&gt; [1] 14 19 20 #&gt; #&gt; $Haustier #&gt; [1] &quot;Hund&quot; &quot;Katze&quot; &quot;Hund&quot; # Liste von Listen erstellen: liste_von_listen &lt;- list(Hanna = list(14, &quot;Hund&quot;), James = list(19, &quot;Katze&quot;), Lin = list(20, &quot;Hund&quot;) ) print(liste_von_listen) #&gt; $Hanna #&gt; $Hanna[[1]] #&gt; [1] 14 #&gt; #&gt; $Hanna[[2]] #&gt; [1] &quot;Hund&quot; #&gt; #&gt; #&gt; $James #&gt; $James[[1]] #&gt; [1] 19 #&gt; #&gt; $James[[2]] #&gt; [1] &quot;Katze&quot; #&gt; #&gt; #&gt; $Lin #&gt; $Lin[[1]] #&gt; [1] 20 #&gt; #&gt; $Lin[[2]] #&gt; [1] &quot;Hund&quot; 2.3.1 Zugriffsoperationen auf Listen # Auf Elemente über den Index zugreifen hanna[[1]] #&gt; [1] &quot;Hanna&quot; # Auf Elemente über den Namen (Schlüssel) zugreifen - Option 1 hanna$Name #&gt; [1] &quot;Hanna&quot; # Auf Elemente über den Namen (Schlüssel) zugreifen - Option 2 hanna[[&quot;Name&quot;]] #&gt; [1] &quot;Hanna&quot; # Auf das erste Element der ersten Liste in einer Liste von Listen über den Index zugreifen liste_von_listen[[1]][1] #&gt; [[1]] #&gt; [1] 14 # Auf das erste Element der ersten Liste in einer Liste von Listen über den Schlüssel zugreifen liste_von_listen[[&quot;Hanna&quot;]][1] #&gt; [[1]] #&gt; [1] 14 # Listen kombinieren mit der Funktion c() emma &lt;- list(Name=&quot;Emma&quot;, Alter=23, Haustier=&quot;Katze&quot;) personen &lt;- c(hanna, emma) Verständnisfragen: Um welche Datenstruktur handelt es sich bei dem Objekt personen? Was ist der Datentyp der Elemente des Objekts personen? Was ist der Unterschied zwischen Listen und Named Vectors? Im letzten Beispiel haben wir die bereits bekannte Funktion c() verwendet, um zwei Listen in eine neue Liste personen zu kombinieren. Das heißt: Wenn wir die Funktion c() verwenden, um zwei Listen zu kombinieren, dann kommt auch eine Liste dabei raus. Man kann mit der Funktion c() aber keine Listen aus einzelnen Werten erstellen: # Mit der Funktion c() kann man KEINE Liste erstellen emma &lt;- c(Name=&quot;Emma&quot;, Alter=23, Haustier=&quot;Katze&quot;) typeof(emma) #&gt; [1] &quot;character&quot; 2.4 Auf einen Blick: Vektoren vs benannte Vektoren vs Faktoren vs Listen In diesem Abschnitt werden die Unterschiede zwischen einfachen Vektoren, benannten Vektoren, Faktoren und Listen anhand eines Beispiels illustriert. Das Beispiel illustriert, wie Daten zu Wetterbedingungen für jeden Monat eines Jahres mithilfe der verschiedenen Datenstrukturen organisiert werden können. # Vektor: Ein einfacher Vektor, der die Wetterbedingungen für jeden Monat eines Jahres speichert. weather_conditions &lt;- c(&quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;regnerisch&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;regnerisch&quot;, &quot;bewölkt&quot;, &quot;bewölkt&quot;, &quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;regnerisch&quot;) avg_rainfall &lt;- c(50, 40, 45, 60, 55, 70, 80, 75, 70, 65, 55, 50) print(weather_conditions) #&gt; [1] &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; #&gt; [6] &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; [11] &quot;bewölkt&quot; &quot;regnerisch&quot; print(avg_rainfall) #&gt; [1] 50 40 45 60 55 70 80 75 70 65 55 50 # Named Vector: Ein benannter Vektor, der die Wetterbedingungen für jeden Monat eines Jahres speichert und Monatsnamen als Namen für jedes Element verwendet. weather_conditions_named &lt;- c(Jan=&quot;sonnig&quot;, Feb=&quot;bewölkt&quot;, Mar=&quot;sonnig&quot;, Apr=&quot;regnerisch&quot;, Mai=&quot;bewölkt&quot;, Jun=&quot;sonnig&quot;, Jul=&quot;regnerisch&quot;, Aug=&quot;bewölkt&quot;, Sep=&quot;bewölkt&quot;, Okt=&quot;sonnig&quot;, Nov=&quot;bewölkt&quot;, Dez=&quot;regnerisch&quot;) print(weather_conditions_named) #&gt; Jan Feb Mar Apr Mai Jun #&gt; &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; Jul Aug Sep Okt Nov Dez #&gt; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;bewölkt&quot; &quot;regnerisch&quot; # Faktor: Häufigkeitsverteilung der Wetterbedingungen # Konvertieren des Vektors in einen Faktor mit benannten Ebenen weather_factor &lt;- factor(weather_conditions, levels=c(&quot;sonnig&quot;, &quot;bewölkt&quot;, &quot;regnerisch&quot;), ordered=TRUE) # Häufigkeitsverteilung der Wetterbedingungen weather_table &lt;- table(weather_factor) # Ergebnis anzeigen print(weather_table) #&gt; weather_factor #&gt; sonnig bewölkt regnerisch #&gt; 4 5 3 # Liste: Eine Liste, die Informationen über das Wetter für jeden Monat des Jahres enthält. # Jedes Element der Liste ist ein eigenes Objekt, in diesem Fall ein Vektor. weather_list &lt;- list(Condition=weather_conditions, Rainfall=avg_rainfall, Month=c(&quot;Januar&quot;, &quot;Februar&quot;, &quot;Maerz&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;, &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot;)) print(weather_list) #&gt; $Condition #&gt; [1] &quot;sonnig&quot; &quot;bewölkt&quot; &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; #&gt; [6] &quot;sonnig&quot; &quot;regnerisch&quot; &quot;bewölkt&quot; &quot;bewölkt&quot; &quot;sonnig&quot; #&gt; [11] &quot;bewölkt&quot; &quot;regnerisch&quot; #&gt; #&gt; $Rainfall #&gt; [1] 50 40 45 60 55 70 80 75 70 65 55 50 #&gt; #&gt; $Month #&gt; [1] &quot;Januar&quot; &quot;Februar&quot; &quot;Maerz&quot; &quot;April&quot; &quot;Mai&quot; &quot;Juni&quot; #&gt; [7] &quot;Juli&quot; &quot;August&quot; &quot;September&quot; &quot;Oktober&quot; &quot;November&quot; &quot;Dezember&quot; # Andere Darstellungsform als Liste von Listen weather_list &lt;- list(Januar=list(50, &quot;sonnig&quot;), Februar=list(40, &quot;bewölkt&quot;), Maerz=list(45, &quot;sonnig&quot;), April=list(60, &quot;regnerisch&quot;), Mai=list(55, &quot;bewölkt&quot;), Juni=list(70, &quot;sonnig&quot;), Juli=list(80, &quot;regnerisch&quot;), August=list(75, &quot;bewölkt&quot;), September=list(70, &quot;bewölkt&quot;), Oktober=list(65, &quot;sonnig&quot;), November=list(55, &quot;bewölkt&quot;), Dezember=list(50, &quot;regnerisch&quot;) ) print(weather_list) #&gt; $Januar #&gt; $Januar[[1]] #&gt; [1] 50 #&gt; #&gt; $Januar[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $Februar #&gt; $Februar[[1]] #&gt; [1] 40 #&gt; #&gt; $Februar[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Maerz #&gt; $Maerz[[1]] #&gt; [1] 45 #&gt; #&gt; $Maerz[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $April #&gt; $April[[1]] #&gt; [1] 60 #&gt; #&gt; $April[[2]] #&gt; [1] &quot;regnerisch&quot; #&gt; #&gt; #&gt; $Mai #&gt; $Mai[[1]] #&gt; [1] 55 #&gt; #&gt; $Mai[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Juni #&gt; $Juni[[1]] #&gt; [1] 70 #&gt; #&gt; $Juni[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $Juli #&gt; $Juli[[1]] #&gt; [1] 80 #&gt; #&gt; $Juli[[2]] #&gt; [1] &quot;regnerisch&quot; #&gt; #&gt; #&gt; $August #&gt; $August[[1]] #&gt; [1] 75 #&gt; #&gt; $August[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $September #&gt; $September[[1]] #&gt; [1] 70 #&gt; #&gt; $September[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Oktober #&gt; $Oktober[[1]] #&gt; [1] 65 #&gt; #&gt; $Oktober[[2]] #&gt; [1] &quot;sonnig&quot; #&gt; #&gt; #&gt; $November #&gt; $November[[1]] #&gt; [1] 55 #&gt; #&gt; $November[[2]] #&gt; [1] &quot;bewölkt&quot; #&gt; #&gt; #&gt; $Dezember #&gt; $Dezember[[1]] #&gt; [1] 50 #&gt; #&gt; $Dezember[[2]] #&gt; [1] &quot;regnerisch&quot; 2.5 Matrizen Eine Matrix ist in R im Grunde eine Kombination mehrerer Vektoren in Spalten und Zeilen. Formell ausgedrückt: In einer Matrix kann jede Spalte und jede Zeile als Vektor aufgefasst werden. Das heißt, dass jedes Element in einer Matrix denselben Datentyp hat, eben genau wie bei Vektoren. Wenn beispielsweise alle Elemente den Typ character haben, spricht man auch von einer character-Matrix. Zusätzlich haben Matrizen eine Dimension, die mithilfe der Funktion dim() abgefragt werden kann. Die Dimension einer Matrix ist die Anzahl ihrer Zeilen und Spalten. Die Matrix unten hat beispielsweise die Dimension 3x3: Sie hat drei Zeilen und drei Spalten. Da Matrizen aus Vektoren bestehen, können Matrizen erstellt werden, indem mehrere Vektoren kombiniert werden, beispielsweise mit der Funktion cbind(). Es ist aber auch möglich, eine Matrix aus einem einzelnen Vektor mithilfe der Funktion matrix() zu erstellen. Dabei wird bei der Erstellung der Matrix mithilfe des Arguments (lernen wir noch) ncol festgelegt, in wie viele Spalten die Elemente des Vektors organisiert werden sollen: # Matrix erstellen mit Funktionen matrix() autos &lt;- matrix(c(&quot;Fiat&quot;, &quot;Mercedes&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Volvo&quot;, &quot;Audi&quot;), ncol = 3) print(autos) #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Fiat&quot; &quot;BMW&quot; &quot;Volvo&quot; #&gt; [2,] &quot;Mercedes&quot; &quot;Ford&quot; &quot;Audi&quot; # Dimension einer Matrix ausgeben lassen dim(autos) #&gt; [1] 2 3 # Matrix erstellen mit der Funktion cbind() fruechte_1 &lt;- c(&quot;Apfel&quot;, &quot;Orange&quot;, &quot;Birne&quot;) fruechte_2 &lt;- c(&quot;Grapefruit&quot;, &quot;Banane&quot;, &quot;Kiwi&quot;) fruechte_mat &lt;- cbind(fruechte_1, fruechte_2) fruechte_mat # statt print() kann man auch einfach den Variablennamen wiederholen #&gt; fruechte_1 fruechte_2 #&gt; [1,] &quot;Apfel&quot; &quot;Grapefruit&quot; #&gt; [2,] &quot;Orange&quot; &quot;Banane&quot; #&gt; [3,] &quot;Birne&quot; &quot;Kiwi&quot; 2.5.1 Zugriffsoperationen auf Matrizen # Zugriff auf Zeile 1 autos[1,] #&gt; [1] &quot;Fiat&quot; &quot;BMW&quot; &quot;Volvo&quot; # Zugriff auf Spalte 1 autos[,1] #&gt; [1] &quot;Fiat&quot; &quot;Mercedes&quot; # Zugriff auf das Element in Zeile 1 und Spalte 2 autos[1,2] #&gt; [1] &quot;BMW&quot; # Spalten (um)benennen colnames(autos) &lt;- c(&quot;rot&quot;, &quot;blau&quot;, &quot;gelb&quot;) # Zeilen (um)benennen rownames(autos) &lt;- c(&quot;neu&quot;, &quot;gebraucht&quot;) # Zugriff auf Spalte mit dem Namen &quot;rot&quot; autos[, &quot;rot&quot;] #&gt; neu gebraucht #&gt; &quot;Fiat&quot; &quot;Mercedes&quot; Die folgenden Beispiele illustrieren nochmal die Eigenschaften von Matrizen: # Matrix ist eine character-Matrix typeof(fruechte_mat) # character #&gt; [1] &quot;character&quot; # Jedes Element hat den Datentyp character typeof(fruechte_mat[1,1]) # character #&gt; [1] &quot;character&quot; Verständnisfragen: Welche Dimension hat die Matrix fruechte_mat? Welchen Datentyp haben die Elemente der Matrix autos? Wie kann man eine Matrix mit zwei Spalten erstellen? 2.6 Arrays Ein Array ermöglicht, einfach gesagt, mehrere Matrizen von gleicher Größe in einer einzigen Datenstruktur zu “stapeln”, wobei jede Matrix eine eigene “Schicht” oder “Ebene” im Array bildet. Auch Arrays haben eine Dimension, allerdings ist damit in Bezug auf Arrays etwas anderes gemeint als in Bezug auf Matrizen. Während die Dimension einer Matrix die Anzahl ihrer Zeilen und Spalten beschreibt, hat der Dimensionsbegriff bei Arrays eine erweiterte Bedeutung. Bei einem Array bezieht sich die Dimension auf die Anzahl der “Richtungen” oder “Achsen”, in denen die Daten organisiert sind. Dies kann die Anzahl der Zeilen, Spalten, “Schichten” und weiterer Organisationsweisen in höherdimensionalen Arrays umfassen. Jede dieser “Richtungen” hat eine bestimmte Größe, das heißt eine festgelegte Anzahl von Elementen. Arrays werden mithilfe der Funktion array() erstellt: # Daten für das Array autos_daten &lt;- c( &quot;Fiat&quot;, &quot;Mercedes&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Volvo&quot;, &quot;Audi&quot;, &quot;Toyota&quot;, &quot;Nissan&quot;, &quot;Honda&quot;, &quot;Chevrolet&quot;, &quot;GMC&quot;, &quot;Tesla&quot; ) # Erstellen eines 3D-Arrays mit 2 Zeilen, 3 Spalten und 2 &quot;Ebenen&quot; (jede Ebene ist eine separate Matrix) autos_array &lt;- array(autos_daten, dim = c(2, 3, 2)) # Ausgabe des Arrays print(autos_array) #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Fiat&quot; &quot;BMW&quot; &quot;Volvo&quot; #&gt; [2,] &quot;Mercedes&quot; &quot;Ford&quot; &quot;Audi&quot; #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Toyota&quot; &quot;Honda&quot; &quot;GMC&quot; #&gt; [2,] &quot;Nissan&quot; &quot;Chevrolet&quot; &quot;Tesla&quot; Die Dimension des Arrays autos_array lässt sich an der Länge des Vektors dim=c(2, 3, 2) ablesen: Da der Vektor drei Elemente hat, handelt es sich um ein dreidimensionales Array. Das erste Element des Vektors dim legt fest, dass jede Matrix zwei Zeilen hat, das zweite Element legt fest, dass jede Matrix drei Spalten hat, und das dritte Element legt fest, dass es zwei Matrizen gibt. 2.6.1 Zugriffsoperationen auf Arrays # Zugriff auf die erste Matrix autos_array[,,1] #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;Fiat&quot; &quot;BMW&quot; &quot;Volvo&quot; #&gt; [2,] &quot;Mercedes&quot; &quot;Ford&quot; &quot;Audi&quot; # Zugriff auf die zweite Spalte der ersten Matrix autos_array[,2,1] #&gt; [1] &quot;BMW&quot; &quot;Ford&quot; # Zugriff auf das Element in der ersten Zeile und zweiten Spalte der ersten Matrix autos_array[1,2,1] #&gt; [1] &quot;BMW&quot; 2.7 Dataframes Dataframes werden zur Darstellung tabellarischer Daten verwendet. Sie ähneln auf den ersten Blick Matrizen, jedoch können sie Elemente unterschiedlichen Typs beinhalten: Jede Spalte eines Dataframes ist ein Vektor, aber anders als bei Matrizen können die Zeilen nicht als Vektoren aufgefasst werden, da die Elemente in den verschiedenen Spalten unterschiedliche Datentypen haben können. Genauer gesagt ist ein Dataframe also eigentlich eine Art von Liste, bei der jedes Element dieselbe Länge haben muss: Eine Liste mit fünf Elementen vom Typ numeric könnte bespielsweise genausogut als Dataframe mit einer Zeile und fünf Spalten dargestellt werden. Eine Liste mit vier Elementen, wobei die Elemente Vektoren mit jeweils zwei Elementen sind, könnte als Dataframe mit zwei Zeilen und vier Spalten dargestellt werden. Weil die Spalten eines Dataframes Vektoren sind, kann man Dataframes “spaltenweise” erstellen. Dazu erstellt man zunächst entweder einen Vektor für jede Spalte und kombiniert diese dann mithilfe der Funktion data.frame() in ein Dataframe-Objekt: # Dataframe aus Vektoren erstellen: Variante 1 marke &lt;- c(&quot;Fiat&quot;, &quot;Mercedes&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Volvo&quot;, &quot;Audi&quot;) farbe &lt;- c(&quot;rot&quot;, &quot;rot&quot;, &quot;blau&quot;, &quot;silber&quot;, &quot;schwarz&quot;, &quot;silber&quot;) jahr &lt;- c(1993, 2007, 1999, 2010, 2020, 2021) df &lt;- data.frame(marke, farbe, jahr) print(df) #&gt; marke farbe jahr #&gt; 1 Fiat rot 1993 #&gt; 2 Mercedes rot 2007 #&gt; 3 BMW blau 1999 #&gt; 4 Ford silber 2010 #&gt; 5 Volvo schwarz 2020 #&gt; 6 Audi silber 2021 # Dataframe aus Vektoren erstellen: Variante 2 # Achtung! Hier verwenden wir jetzt den Operator = df &lt;- data.frame(marke = c(&quot;Fiat&quot;, &quot;Mercedes&quot;, &quot;BMW&quot;, &quot;Ford&quot;, &quot;Volvo&quot;, &quot;Audi&quot;), farbe = c(&quot;rot&quot;, &quot;rot&quot;, &quot;blau&quot;, &quot;silber&quot;, &quot;schwarz&quot;, &quot;silber&quot;), jahr = c(1993, 2007, 1999, 2010, 2020, 2021) ) print(df) #&gt; marke farbe jahr #&gt; 1 Fiat rot 1993 #&gt; 2 Mercedes rot 2007 #&gt; 3 BMW blau 1999 #&gt; 4 Ford silber 2010 #&gt; 5 Volvo schwarz 2020 #&gt; 6 Audi silber 2021 Oder man erstellt eine Liste, bei der jedes Element ein Vektor ist und stellt die Liste anschließend mit der Funktion as.data.frame() als Dataframe dar: # Dataframe aus einer Liste erstellen personen &lt;- list(namen = c(&quot;Hans&quot;, &quot;Peter&quot;), alter = c(23, 50)) personen_df &lt;- as.data.frame(personen, col.names = c(&quot;Name&quot;, &quot;Alter&quot;)) print(personen_df) #&gt; Name Alter #&gt; 1 Hans 23 #&gt; 2 Peter 50 2.7.1 Zugriffsoperationen auf Dataframes # Zugriff auf eine Spalte über den Namen der Spalte df$farbe #&gt; [1] &quot;rot&quot; &quot;rot&quot; &quot;blau&quot; &quot;silber&quot; &quot;schwarz&quot; &quot;silber&quot; # Zugriff auf einzelne Elemente über den Spaltennamen und den Index der Zeile df$farbe[3] #&gt; [1] &quot;blau&quot; # Zugriff auf Zeile 1 df[1,] #&gt; marke farbe jahr #&gt; 1 Fiat rot 1993 # Zugriff auf Spalte 1 df[,1] #&gt; [1] &quot;Fiat&quot; &quot;Mercedes&quot; &quot;BMW&quot; &quot;Ford&quot; &quot;Volvo&quot; &quot;Audi&quot; # Zugriff auf das Element in Zeile 1 und Spalte 2 df[1,2] #&gt; [1] &quot;rot&quot; # Zugriff auf Elemente in der Spalte Marke, für die gilt, dass in derselben Zeile in der Spalte Farbe der character &quot;rot&quot; steht df$marke[df$farbe == &quot;rot&quot;] #&gt; [1] &quot;Fiat&quot; &quot;Mercedes&quot; # Zugriff auf Elemente in der Spalte Marke, für die gilt, dass in derselben Zeile in der Spalte Jahr ein Wert größer als 2010 steht df$marke[df$jahr &gt; 2010] #&gt; [1] &quot;Volvo&quot; &quot;Audi&quot; # Spalte hinzufügen df$gebraucht &lt;- c(TRUE, TRUE, FALSE, FALSE, FALSE, TRUE) df #&gt; marke farbe jahr gebraucht #&gt; 1 Fiat rot 1993 TRUE #&gt; 2 Mercedes rot 2007 TRUE #&gt; 3 BMW blau 1999 FALSE #&gt; 4 Ford silber 2010 FALSE #&gt; 5 Volvo schwarz 2020 FALSE #&gt; 6 Audi silber 2021 TRUE # Spaltennamen kann man nachträglich ändern colnames(personen_df) &lt;- c(&quot;Vorname&quot;, &quot;Jahre&quot;) Verständnisfragen: Was gilt für alle Spalten eines Dataframes? Welchen Datentyp haben die Werte in der neuen Spalte “gebraucht”? Was passiert, wenn Werte beim Erstellen eines Dataframes fehlen? Löscht einen Wert und probiert es aus. Verwendet die Funktion View() um euch einen der Dataframes genauer anzusehen. Was passiert? Die folgenden Beispiele illustrieren noch einmal die Eigenschaften von Dataframes: # Elemente in einem Dataframe können unterschiedliche Datentypen haben typeof(df[2,3]) # numeric/double #&gt; [1] &quot;double&quot; # Elemente in einem Dataframe können unterschiedliche Datentypen haben typeof(df[1,1]) # character #&gt; [1] &quot;character&quot; # Spalten sind Vektoren typeof(personen_df$Name) # character (vector) #&gt; [1] &quot;NULL&quot; # Zeilen sind Listen typeof(personen_df[1,]) # list #&gt; [1] &quot;list&quot; 2.8 Auf einen Blick: Matrizen vs Arrays vs Dataframes In diesem Abschnitt werden die Unterschiede zwischen Matrizen, Arrays und Dataframes anhand eines Beispiels illustriert. Das Beispiel illustriert, wie Daten zu Temperaturmessungen in drei verschiedenen Städten an drei Tageszeiten mithilfe der verschiedenen Datenstrukturen organisiert werden können. # Array: Ein dreidimensionales Modell zur Speicherung von Temperaturdaten über eine Woche, gemessen zu verschiedenen Tageszeiten in verschiedenen Städten. # Ein 3x7x3 Array erstellen für 3 Städte, 7 Tage und 3 Tageszeiten temperature_data_array &lt;- array(sample(10:30, 63, replace = TRUE), dim = c(3,7,3)) dimnames(temperature_data_array) &lt;- list( Stadt = c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;München&quot;), Tag = c(&quot;Mo&quot;, &quot;Di&quot;, &quot;Mi&quot;, &quot;Do&quot;, &quot;Fr&quot;, &quot;Sa&quot;, &quot;So&quot;), Zeit = c(&quot;Morgen&quot;, &quot;Mittag&quot;, &quot;Abend&quot;) ) print(temperature_data_array[,&quot;Mo&quot;, &quot;Morgen&quot;]) #&gt; Berlin Hamburg München #&gt; 24 24 11 print(temperature_data_array) #&gt; , , Zeit = Morgen #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 24 24 27 23 25 28 23 #&gt; Hamburg 24 19 30 29 12 15 23 #&gt; München 11 14 29 27 19 28 26 #&gt; #&gt; , , Zeit = Mittag #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 18 23 25 25 20 26 23 #&gt; Hamburg 17 24 26 24 30 28 11 #&gt; München 30 11 21 16 28 23 25 #&gt; #&gt; , , Zeit = Abend #&gt; #&gt; Tag #&gt; Stadt Mo Di Mi Do Fr Sa So #&gt; Berlin 24 25 21 18 18 15 18 #&gt; Hamburg 19 25 11 25 29 16 18 #&gt; München 25 14 16 20 28 11 28 # Matrix: Die Temperaturmessungen für alle Städte über eine Woche zu einer bestimmten Tageszeit. morning_temperature_matrix &lt;- matrix(temperature_data_array[ , , &quot;Morgen&quot;], nrow = 7) rownames(morning_temperature_matrix) &lt;- c(&quot;Mo&quot;, &quot;Di&quot;, &quot;Mi&quot;, &quot;Do&quot;, &quot;Fr&quot;, &quot;Sa&quot;, &quot;So&quot;) colnames(morning_temperature_matrix) &lt;- c(&quot;Berlin&quot;, &quot;Hamburg&quot;, &quot;München&quot;) print(morning_temperature_matrix) #&gt; Berlin Hamburg München #&gt; Mo 24 30 19 #&gt; Di 24 29 28 #&gt; Mi 11 23 15 #&gt; Do 24 29 28 #&gt; Fr 19 27 23 #&gt; Sa 14 25 23 #&gt; So 27 12 26 # Dataframe: Die Temperaturmessungen für alle Städte über eine Woche zu einer bestimmten Tageszeit. morning_temperature_dataframe &lt;- data.frame( Berlin = temperature_data_array[&quot;Berlin&quot;, , &quot;Morgen&quot;], Hamburg = temperature_data_array[&quot;Hamburg&quot;, , &quot;Morgen&quot;], München = temperature_data_array[&quot;München&quot;, , &quot;Morgen&quot;] ) print(morning_temperature_dataframe) #&gt; Berlin Hamburg München #&gt; Mo 24 24 11 #&gt; Di 24 19 14 #&gt; Mi 27 30 29 #&gt; Do 23 29 27 #&gt; Fr 25 12 19 #&gt; Sa 28 15 28 #&gt; So 23 23 26 # Der Dataframe sieht auf den ersten Blick genauso aus wie die Matrix. # Ein Dataframe kann aber zusätzliche Metadaten und Werte eines anderen Datentyps enthalten: morning_temperature_dataframe$Zeit &lt;- &quot;Morgen&quot; morning_temperature_dataframe$Skala &lt;- &quot;Celsius&quot; print(morning_temperature_dataframe) #&gt; Berlin Hamburg München Zeit Skala #&gt; Mo 24 24 11 Morgen Celsius #&gt; Di 24 19 14 Morgen Celsius #&gt; Mi 27 30 29 Morgen Celsius #&gt; Do 23 29 27 Morgen Celsius #&gt; Fr 25 12 19 Morgen Celsius #&gt; Sa 28 15 28 Morgen Celsius #&gt; So 23 23 26 Morgen Celsius # Wenn wir dasselbe mit der Matrix versuchen, bekommen wir dagegen eine Warnmeldung, und einen wenig sinnvollen Output: morning_temperature_matrix$Zeit &lt;- &quot;Morgen&quot; #&gt; Warning in morning_temperature_matrix$Zeit &lt;- &quot;Morgen&quot;: Coercing LHS to a list # Auf die Werte in einem Dataframe können auch komplexere Operationen angewandt werden, und die Ergebnisse der Opterationen kann direkt im Dataframe gespeichert werden. # Wir können zum Beispiel das Maximum für jeden Tag berechenen und eine neue Spalte &quot;Maximum&quot; für diesen Wert übertragen morning_temperature_dataframe$Maximum &lt;- pmax(morning_temperature_dataframe$Berlin, morning_temperature_dataframe$Hamburg, morning_temperature_dataframe$München) morning_temperature_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum #&gt; Mo 24 24 11 Morgen Celsius 24 #&gt; Di 24 19 14 Morgen Celsius 24 #&gt; Mi 27 30 29 Morgen Celsius 30 #&gt; Do 23 29 27 Morgen Celsius 29 #&gt; Fr 25 12 19 Morgen Celsius 25 #&gt; Sa 28 15 28 Morgen Celsius 28 #&gt; So 23 23 26 Morgen Celsius 26 # Wir könnten auch die Werte in Fahrenheit umwandeln morning_temperature_dataframe$Maximum &lt;- morning_temperature_dataframe$Maximum * 9/5 + 32 morning_temperature_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum #&gt; Mo 24 24 11 Morgen Celsius 75.2 #&gt; Di 24 19 14 Morgen Celsius 75.2 #&gt; Mi 27 30 29 Morgen Celsius 86.0 #&gt; Do 23 29 27 Morgen Celsius 84.2 #&gt; Fr 25 12 19 Morgen Celsius 77.0 #&gt; Sa 28 15 28 Morgen Celsius 82.4 #&gt; So 23 23 26 Morgen Celsius 78.8 #... und anschließend die Spalte umbenennen morning_temperature_dataframe$Maximum_Fahrenheit &lt;- morning_temperature_dataframe$Maximum morning_temperature_dataframe$Maximum &lt;- NULL # entfernt die ursprüngliche &quot;Maximum&quot; Spalte morning_temperature_dataframe #&gt; Berlin Hamburg München Zeit Skala Maximum_Fahrenheit #&gt; Mo 24 24 11 Morgen Celsius 75.2 #&gt; Di 24 19 14 Morgen Celsius 75.2 #&gt; Mi 27 30 29 Morgen Celsius 86.0 #&gt; Do 23 29 27 Morgen Celsius 84.2 #&gt; Fr 25 12 19 Morgen Celsius 77.0 #&gt; Sa 28 15 28 Morgen Celsius 82.4 #&gt; So 23 23 26 Morgen Celsius 78.8 # Zur Datenmanipulation werden wir deswegen meist mit Dataframes zu tun haben. 2.9 Fehlende und ungültige Werte in Datenstrukturen Bei der Arbeit mit Daten in R kommt es immer mal vor, dass Werte fehlen oder ungültig sind. In R gibt es spezielle Objekte, die in diesem Fall eingesetzt werden. Der Wert NULL wird eingesetzt, um die Nicht-Existenz von Daten zu signalisieren. Das haben wir gesehen, als wir mithilfe der Funktion c() einen leeren Vektor erstellt haben. NULL wird außerdem dazu verwendet, um Werte aus Listen oder Dataframes zu entfernen. Wir haben dieses Objekt beispielsweise verwendet, um die Spalte Maximum aus dem Dataframe morning_temperature_dataframe zu entfernen. Daneben gibt es NA, was für Not Available oder “nicht verfügbar” steht und verwendet wird, um das Fehlen von erwarteten Werten in Datenstrukturen zu markieren. Dieser Wert kommt typischerweise in Dataframes zur Anwendung, wenn zu einigen Beobachtungen bestimmte Werte fehlen, zum Beispiel das Alter einer Person in einem Dataframe, der Daten zu verschiedenen Personen enthält. Zuletzt gibt es den Wert NaN, welcher für Not a Number oder “keine Zahl” steht und signalisiert, dass das Ergebnis einer Berechnung eine undefinierte Zahl ist oder eine Zahl, die nicht repräsentiert werden kann. Ein Beispiel ist das Ergebnis der Operation 0/0. 2.10 Der Mitgliedschaftsoperator %in% Am Anfang haben wir Datenstrukturen als strukturierte Sammlungen von Werten (oder anderen Objekten) definiert. Um schnell herauszufinden, ob sich ein Wert in einer Datenstruktur befindet, kann ein spezieller Operator verwendet werden: der sogenannte Migliedschaftsoperator %in%. Dieser Operator wird auf Vektoren angewendet: Entweder auf einzelne Vektoren oder auf Vektoren innerhalb einer anderen Datenstruktur, also zum Beispiel auf die Spalten eines Dataframes oder Listenelemente, die Vektoren sind. Ein paar Beispiele: buchstaben &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;f&quot;, &quot;s&quot;, &quot;g&quot;) &quot;a&quot; %in% buchstaben #&gt; [1] TRUE # Es kann auch direkt nach der Mitgliedschaft mehrerer Elemente gefragt werden: c(&quot;a&quot;, &quot;f&quot;, &quot;b&quot;) %in% buchstaben #&gt; [1] TRUE TRUE TRUE # Mitgliedschaftsoperator auf Elemente einer Liste anwenden obstpreise &lt;- list(obst=c(&quot;Apfel&quot;, &quot;Banane&quot;, &quot;Orange&quot;), preise=c(2.45, 2.99, 1.99)) &quot;Orange&quot; %in% obstpreise$obst #&gt; [1] TRUE 2.11 Unveränderbarkeit von Objekten in R Wir haben in der vergangenen Woche besprochen, dass bei der Zuweisung einer Variable ein Wert zugeordnet wird, indem ein Name festgelegt wird, der fortan für diesen Wert und für den Speicherplatz, in dem er gespeichert ist, steht. Der Name ist also sowas wie eine Referenz zu diesem Wert. Aber was passiert eigentlich, wenn der Wert im Programmverlauf verändert wird? Dieser Frage gehen wir an einem Beispiel nach. Wir weisen zunächst einer Variable x einen Vektor c(1, 2, 3) als Wert zu: x &lt;- c(1,2,3) Die folgende Grafik aus dem Buch “Advanced R” von Hadley Wickham illustriert, was bei der Zuweisungsoperation passiert: Der Name x referenziert also nach der Zuweisung einen Vektor mit den Elementen 1, 2 und 3. Die graue Zahl 0x74b steht für die Adresse des Speicherplatzes, der im Computer für das Objekt (den Vektor) “reserviert” ist. Wenn die Variable x einer neuen Variable y zugewiesen wird, dann referenziert auch der Name y denselben Wert, es entsteht zunächst also keine Kopie des Werts c(1, 2, 3): y &lt;- x Aber was passiert mit der Variable x, wenn die Variable y verändert wird? Oder, korrekter formuliert: Welchen Wert referenziert x, wenn mithilfe von y auf den der Wert c(1, 2, 3) zugegriffen und ein Element verändert wird? x &lt;- c(1, 2, 3) y &lt;- x y[3] &lt;- 4 x #&gt; [1] 1 2 3 y wird zwar verändert, aber x nicht! Der Wert, der mit y verknüpft ist, wurde verändert, aber das ursprüngliche Objekt nicht. Stattdessen wurde ein neues Objekt erstellt, das eine Kopie des ursprünglichen Objekts mit dem veränderten Wert ist. Dieses Verhalten liegt daran, dass R Objekte unveränderbar, oder auf Englisch immutable sind. Das bedeutet: Wenn wir in R den Wert einer Variable ändern wollen, z.B. x &lt;- x + 1, dann wird tatsächlich ein neues Objekt erstellt und x wird nun auf den neuen Speicherplatz, der den neuen Wert enthält, verwiesen. Der alte Speicherplatz wird freigegeben, wenn keine andere Variable darauf verweist. Bei der Manipulation von Objekten sollte man also dieses Prinzip der Unveränderbarkeit (Immutability) im Hinterkopf behalten, denn hier unterscheidet sich R von anderen Programmiersprachen wie beispielsweise Python. Diese Beispiele und alle Erklärungen auf Englisch könnt ihr auch nochmal im Kapitel “Binding basics” in Wickhams Lehrbuch “Advanced R” nachlesen. An diesem Punkt sollt ihr aber hauptsächlich das Prinzip der Unveränderbarkeit mal gehört haben; es ist nicht schlimm, wenn ihr den Vorgang nicht im Detail versteht. Quellen Quellen aktualisieren nur für Datenstrukturen Venables, W.N. and Smith, D.M. and the R Core Team (2023). An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Wickham, Hadley (2019). Advanced R. Chapter 2: Names and Values, https://adv-r.hadley.nz/names-values.html Reussner, Ralf H. Mitschnitt zur Vorlesung “Programmieren” im WiSe 2015/2016. 02: Typen und Variablen, https://www.youtube.com/watch?v=POe41EL2EgU R 4.3.0 Documentation. Operator Syntax and Precedence, https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html Wickham, Hadley (2019). Advanced R. Chapter 4: Subsetting, https://adv-r.hadley.nz/subsetting.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
