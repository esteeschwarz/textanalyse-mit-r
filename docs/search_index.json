[["r-basics-iii-kontrollstrukturen.html", "3 R Basics III: Kontrollstrukturen 3.1 Grundlegende Begriffe 3.2 Bedingte Anweisungen 3.3 Verzweigungen 3.4 while-Schleifen 3.5 for-Schleifen 3.6 Schleifen abbrechen Quellen", " 3 R Basics III: Kontrollstrukturen Bisher haben wir in unseren Beispielen immer einzelne Anweisungen oder Ausdrücke (-&gt; Grundbegriffe!) betrachtet. Wir haben dabei gelernt, dass der Computer Code ausführen und auswerten kann: Beim Ausführen “macht” er etwas und ändert den Zustand des Speichers, zum Beispiel, wenn eine neue Variable erstellt wird. Beim Auswerten berechnet er etwas und liefert einen Wert, zum Beispiel, wenn eine logische Aussage überprüft wird. Der Computer kann Anweisungen aber auch wiederholen oder Anweisungen nur dann ausführen, wenn eine bestimmte Bedingung erfüllt ist. In R gibt es eine Reihe von Signalwörtern, die dem Computer mitteilen, dass eine bestimmte Abfolge von Anweisungen (=Anweisungsblock) wiederholt werden soll oder nur unter einer bestimmten Bedingung ausgeführt werden soll. 3.1 Grundlegende Begriffe Begriff Englische Entsprechung Definition (im R-Kontext) Anweisungsblock Code block Mehrere aufeinanderfolgende Codezeilen, zum Beispiel im Körper einer Schleife oder einer bedingten Anweisung. Iteration Iteration Im Kontext von Kontrollstrukturen bezeichnet Iteration zwei Dinge: in einem allgemeinen Sinn den Prozess, bei dem Anweisungen wiederholt ausgeführt werden, und zum anderen einen einzigen Schleifendurchlauf, also das einmalige Ausführen der Anweisungen im Schleifenkörper. Wenn der Code einmal ausgeführt wird, sagt man entsprechend ‘eine Iteration’, für das zweimalige Ausführen ‘zwei Iterationen’, usw. Iterieren Iterate Wenn beschrieben werden soll, dass eine for-Schleife ein Objekt durchläuft, wird dazu häufig gesagt, dass die Schleife ‘über das Objekt iteriert’. Terminieren Terminate Wenn eine Schleife terminiert bedeutet das, dass sie die Ausführung beendet; sie kommt zum Ende. Style Tip In Funktionsaufrufen, also z.B. print(), und in Zugriffsoperationen, also z.B. var[], steht bekanntlich kein Leerzeichen vor der Klammer. Bei Kontrollstrukturen ist das anders. Hier empfiehlt Wickham, nach den Signalwörtern if, if else, for und while stets ein Leerzeichen einzufügen, also z.B. if (var == 20). 3.2 Bedingte Anweisungen Bedingte Anweisungen, oder if-Anweisungen, haben die allgemeine Form: if (Bedingung) { Anweisungsblock } if (Bedingung) { Anweisungsblock if (Bedingung) { Anweisungsblock } } Beispiel: # Nachricht wird ausgegeben, wenn der Vektor autos ein Element mit dem Wert &quot;Mercedes&quot; enthält autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; # Nachricht wird ausgegeben, wenn der Wert, der dem Schlüssel &quot;Mercedes&quot; im Vektor autos zugeordnet ist, größer als 1 ist autos &lt;- c(Mercedes=2, Fiat=1, Volvo=1, BMW=3) anzahl_mercedes &lt;- autos[&quot;Mercedes&quot;] if (anzahl_mercedes &gt; 1) { print(paste(&quot;Du hast&quot;, anzahl_mercedes, &quot;Mercedes!&quot;)) } ## [1] &quot;Du hast 2 Mercedes!&quot; Mit der Funktion paste() können character verkettet werden. Dabei werden automatisch Leerzeichen zwischen den zu verkettenden charactern eingefügt. Wenn character ohne Leerzeichen verkettet werden sollen, kann stattdessen die Funktion paste0() verwendet werden. # Wenn der Vektor autos einen Schlüssel &quot;Mercedes&quot; enthält, wird überprüft, ob der Wert, der diesem Schlüssel zugeordnet ist, größer als 1 ist. # Falls ja, wird eine Nachricht ausgegeben. autos &lt;- c(Mercedes=2, Fiat=1, Volvo=1, BMW=3) if (&quot;Mercedes&quot; %in% names(autos)) { anzahl_mercedes &lt;- autos[&quot;Mercedes&quot;] if (anzahl_mercedes &gt; 1) { print(paste(&quot;Du hast&quot;, anzahl_mercedes, &quot;Mercedes!&quot;)) } } ## [1] &quot;Du hast 2 Mercedes!&quot; Verständnisfragen: Welche Datenstruktur hat das Objekt autos im zweiten und dritten Beispiel? Wie müsste man den Code im ersten Beispiel ändern, sodass eine Nachricht ausgegeben wird, wenn sowohl ein Mercedes als auch ein Fiat in der Garage stehen? Bedingungen können auch kombiniert werden. Dazu werden einfach zwei logische Ausdrücke mithilfe der logischen Operatoren &amp;&amp; und || verknüpft: # Beide Ausdrücke sind wahr: die Nachricht wird ausgegeben autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos &amp;&amp; &quot;Fiat&quot; %in% autos) { print(&quot;Ein Mercedes und ein Fiat stehen in der Garage!&quot;) } ## [1] &quot;Ein Mercedes und ein Fiat stehen in der Garage!&quot; # Einer der Ausdrücke ist falsch: es passiert nichts autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos &amp;&amp; &quot;Opel&quot; %in% autos) { print(&quot;Ein Mercedes und ein Opel stehen in der Garage!&quot;) } # Einer der Ausdrücke ist falsch: die Nachricht wird ausgegeben autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos || &quot;Opel&quot; %in% autos) { print(&quot;Ein Mercedes oder ein Opel steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes oder ein Opel steht in der Garage!&quot; 3.3 Verzweigungen Es wird unterschieden zwischen einfachen und mehrfachen Verzweigungen. Einfache Verzweigungen, oder if-else-Anweisungen, haben die allgemeine Form: if (Bedingung) { Anweisungsblock } else { Anweisungsblock } Beispiel: # Wenn der Wert, der dem Schlüssel &quot;Ibuprofen&quot; zugeordnet ist, größer 0 ist, wird eine Nachricht ausgegeben. # Wenn der Wert 0 (oder im theoretischen Fall kleiner 0) ist, wird eine Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] if (anzahl_ibus &gt; 0) { print(paste(&quot;Du hast&quot;, anzahl_ibus, &quot;Ibuprofen!&quot;)) } else { print(&quot;Warnung: kein Ibuprofen mehr da!&quot;) } ## [1] &quot;Du hast 30 Ibuprofen!&quot; Wenn mehr als zwei Fälle überprüft werden sollen, kann eine if-else-Anweisung mit beliebig vielen zusätzlichen bedingten Anweisungen kombiniert werden. Mehrfache Verzweigungen haben die allgemeine Form: if (Bedingung) { Anweisungsblock } else if (Bedingung) { Anweisungsblock } else { Anweisungsblock } # Wenn der Wert, der dem Schlüssel &quot;Ibuprofen&quot; zugeordnet ist, größer als 5 ist, wird eine Nachricht mit dem Wert ausgegeben. # Wenn der Wert genau dem Integer 5 entspricht, wird eine Warnung ausgegeben. # In allen anderen Fällen wird die Nachricht &quot;Achtung! Weniger als 5 Ibuprofen da!&quot; ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] if (anzahl_ibus &gt; 5) { print(paste(&quot;Du hast&quot;, anzahl_ibus, &quot;Ibuprofen!&quot;)) } else if (anzahl_ibus == 5) { print(&quot;Warnung: Nur noch 5 Ibuprofen da!&quot;) } else { print(&quot;Achtung! Weniger als 5 Ibuprofen da!&quot;) } ## [1] &quot;Du hast 30 Ibuprofen!&quot; Verständnisfragen: Wann wird der Anweisungsblock nach else ausgeführt? Welche Bedingung muss erfüllt sein? Achtung: Wenn zwei Bedingungen in einer Verzweigung zugleich erfüllt sind, wird nur die bedingte Anweisung ausgeführt, die zuerst überprüft wurde, die also “weiter oben” im Skript steht. Zur Illustration schauen wir uns nochmal unser Auto-Beispiel an. # Sowohl die if-Bedingung als auch die if else-Bedingung werden zu True evaluiert. # Allerdings wird die if else-Bedingung nie ausgewertet. # Es wird also nur die if-Anweisung ausgeführt. autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } else if (&quot;Fiat&quot; %in% autos) { print(&quot;Ein Fiat steht in der Garage!&quot;) } else { print(&quot;Weder ein Mercedes noch ein Fiat in der Garage.&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; Dieses Verhalten gilt allerdings nur für Verzweigungen, nicht jedoch für zwei if-Anweisungen, die aufeinander folgen: # Beide if-Bedingungen werden nacheinander ausgewertet. Im ersten Schleifendurchlauf # werden beide zu True evaluiert und es werden beide Anweisungen ausgeführt. autos &lt;- c(&quot;Mercedes&quot;, &quot;Fiat&quot;, &quot;Volvo&quot;, &quot;BMW&quot;) if (&quot;Mercedes&quot; %in% autos) { print(&quot;Ein Mercedes steht in der Garage!&quot;) } ## [1] &quot;Ein Mercedes steht in der Garage!&quot; if (&quot;Fiat&quot; %in% autos) { print(&quot;Ein Fiat steht in der Garage!&quot;) } ## [1] &quot;Ein Fiat steht in der Garage!&quot; Eine spezielle Form von Verzweigung sind bedingte Ausdrücke. Diese werden verwendet, um einer Variable in Abhängigkeit von einer anderen Variable einen Wert zuzuweisen. Bedingte Ausdrücke stellen eine Kurzschreibweise für die folgende Verzweigung dar: # Kompliziert x &lt;- 2 if (x == 2) { var &lt;- 10 } else { var &lt;- 20 } # Einfach x &lt;- 2 var &lt;- if (x == 2) 10 else 20 # Alternative (macht dasselbe): Die ifelse-Funktion var &lt;- ifelse(x == 2, 10, 20) 3.4 while-Schleifen while-Schleifen werden verwendet, wenn ein Code-Block (=nur ein anderes Wort für Anweisungsblock) so lange ausgeführt werden soll, wie eine bestimmte Bedingung erfüllt ist. Die Bedingung steht im Schleifenkopf und wird überprüft, bevor der Code im Schleifenkörper ausgeführt wird. Wenn die Bedingung nicht (mehr) erfüllt ist, terminiert die Schleife. while-Schleifen haben die allgemeine Form: while (Bedingung) { Anweisungsblock } Beispiel: # In jedem Schleifendurchlauf wird zunächst der Ausdruck anzahl_ibus &gt; 0 ausgewertet. # Wenn der Ausdruck zu True evaluiert wird, wird die Anweisung im Schleifenkörper ausgeführt, d.h. der Wert der Variable anzahl_ibus wird um 1 verringert. # Wenn die Variable anzahl_ibus den Wert 0 annimmt, wird der Ausdruck im Schleifenkopf zu False evaluiert und die Schleife terminiert. # Nach dem Terminieren der Schleife wird eine Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] while (anzahl_ibus &gt; 0) { anzahl_ibus &lt;- anzahl_ibus - 1 } print(&quot;Warnung: kein Ibuprofen mehr da!&quot;) ## [1] &quot;Warnung: kein Ibuprofen mehr da!&quot; Verständnisfragen: Nach wie vielen Schleifendurchläufen wird die Meldung “Achtung! Kein Ibuprofen mehr da!” ausgegeben? Nach wie vielen Schleifendurchläufen terminiert die Schleife? Es ist auch möglich, while-Schleifen und bedingte Anweisungen zu kombinieren: # In jedem Schleifendurchlauf wird zunächst der Ausdruck anzahl_ibus &gt; 0 ausgewertet. # Wenn der Ausdruck zu True evaluiert wird, wird überprüft, ob der Wert dem Integer 5 entspricht. # Falls ja, wird eine Warnmeldung ausgegeben. # Danach wird der Wert der Variable anzahl_ibus um 1 verringert. # Wenn die Variable anzahl_ibus den Wert 0 annimmt, wird der Ausdruck im Schleifenkopf zu False evaluiert und die Schleife terminiert. # Nach dem Terminieren der Schleife wird eine weitere Warnung ausgegeben. medikamente &lt;- c(Ibuprofen=30, Paracetamol=23, Aspirin=28) anzahl_ibus &lt;- medikamente[&quot;Ibuprofen&quot;] while (anzahl_ibus &gt; 0) { if (anzahl_ibus == 5) { print(&quot;Warnung: nur noch 5 Ibuprofen da!&quot;) } anzahl_ibus &lt;- anzahl_ibus - 1 } ## [1] &quot;Warnung: nur noch 5 Ibuprofen da!&quot; print(&quot;Achtung! Kein Ibuprofen mehr da!&quot;) ## [1] &quot;Achtung! Kein Ibuprofen mehr da!&quot; Verständnisfrage: Wir wollen sichergehen, dass die Warnung wirklich im 26. Schleifendurchlauf ausgegeben wird. Wie könnten wir den Code ändern, damit in jedem Schleifendurchgang zusätzlich ein Wert ausgegeben wird? Achtung: while-Schleifen laufen unendlich lange, wenn die Abbruchbedingung nie erfüllt ist: # while (TRUE) { # print(&quot;Dies ist eine unendliche Schleife&quot;) #} Falls ihr versehentlich doch mal eine unendliche Schleife im RStudio ausgeführt haben solltet, könnt ihr die Ausführung der Schleife im RStudio abbrechen. Dazu könnt ihr entweder auf das rote Stopp-Zeichen oben rechts im Konsole-Fenster klicken oder ihr gebt dir Tastenkombination CTRL + C (Mac) bzw. Escape (Windows) ein. 3.5 for-Schleifen for-Schleifen werden verwendet, um iterierbare Objekte zu durchlaufen. Listen und Vektoren sind in R iterierbar; und weil Matrizen und Dataframes aus Vektoren bzw. Listen bestehen, sind auch Matrizen und Dataframes iterierbar. Iterieren bedeutet einfach “durchlaufen”. Im Kopf der for-Schleife steht anders als bei der while-Schleife keine Bedingung, sondern es wird eine Variable festgelegt, die als Platzhalter für den Wert der Elemente des Objekts dient. Diese Variable nennt man auch Laufvariable. Die for-Schleife “durchläuft” also im Grunde das Objekt, indem in jedem Schleifendurchlauf die Laufvariable den Wert des aktuellen Elements annimmt – und das so lange, bis es keine weiteren Elemente mehr gibt. Mithilfe des Variablennamens kann im Schleifenkörper auf den Wert des aktuellen Elements zugegriffen werden. Einen Schleifendurchlauf nennt man auch eine Iteration. for-Schleifen haben in R die allgemeine Form: for (Element in Objekt) { Anweisungsblock } Beispiel: # In jedem Schleifendurchlauf nimmt die Laufvariable zahl den Wert eines Elements aus dem # Vektor zahlen an und es wird der aktuelle Wert der Variable zahl, addiert mit 1, ausgegeben. woerter &lt;- c(&quot;Netzwerkdurchsetzungsgesetz&quot;, &quot;Abfallverzeichnisverordnung&quot;, &quot;Haftpflichtversicherung&quot;, &quot;Antivirenprogramm&quot;) for (wort in woerter) { print(paste(wort, nchar(wort))) } ## [1] &quot;Netzwerkdurchsetzungsgesetz 27&quot; ## [1] &quot;Abfallverzeichnisverordnung 27&quot; ## [1] &quot;Haftpflichtversicherung 23&quot; ## [1] &quot;Antivirenprogramm 17&quot; Mithilfe der Funktion nchar() kann die Anzahl der Zeichen in einer Zeichenkette (=character) bestimmt werden. Wie while-Schleifen können auch for-Schleifen mit bedingten Anweisungen kombiniert werden: # In jedem Schleifendurchlauf nimmt die Laufvariable wort den Wert eines Elements aus dem Vektor woerter (s.o.) an. # Zunächst wird die Zeichenanzahl des aktuellen Strings der Variable laenge als Wert zugewiesen. # Dann wird geprüft, ob der Wert der Variable zeichen größer als 20 ist. # Falls ja, wird der Liste lange_woerter ein Element mit dem aktuellen Wert der Variable wort als Schlüssel und der Zeichenanzahl als Wert hinzugefügt. # Wenn der Vektor woerter keine weiteren Elemente mehr enthält, terminiert die Schleife. # Danach wird die Liste lange_woerter ausgegeben. woerter &lt;- c(&quot;Netzwerkdurchsetzungsgesetz&quot;, &quot;Abfallverzeichnisverordnung&quot;, &quot;Haftpflichtversicherung&quot;, &quot;Antivirenprogramm&quot;) lange_woerter &lt;- list() for (wort in woerter) { zeichen &lt;- nchar(wort) if (zeichen &gt; 20) { lange_woerter[[wort]] &lt;- zeichen } } print(lange_woerter) ## $Netzwerkdurchsetzungsgesetz ## [1] 27 ## ## $Abfallverzeichnisverordnung ## [1] 27 ## ## $Haftpflichtversicherung ## [1] 23 Es muss jedoch beachtet werden, dass Elemente eines iterierbaren Objekts im Laufe einer Iteration nicht direkt verändert werden können: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (tier in tiere) { tier &lt;- tolower(tier) } # Änderungen wurden nicht übernommen print(tiere) ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; Mithilfe der Funktion tolower() können Buchstaben in einer Zeichenkette (=character) automatisch in Kleinbuchstaben umgewandelt werden. Das liegt daran, dass die Laufvariable nur für den Wert des aktuellen Elements steht, nicht für dieses Element selbst. Die Laufvariable haben wir also eigentlich bisher als “Wertvariable” verwendet. Um Elemente im Schleifendurchlauf zu verändern, muss mithilfe der Indexposition direkt auf ein Element aus dem Vektor oder der Liste zugegriffen werden, also genau so, wie wir bisher auch auf Elemente zugegriffen haben. Doch mit jedem Schleifendurchlauf nimmt die Laufvariable ja den Wert eines anderen Elements an; die Indexposition des aktuellen Elements ändert sich also fortlaufend. Um auf Elemente in einem Schleifendurchlauf zuzugreifen, brauchen wir also eine Variable, die nicht den Wert des aktuellen Elements annimmt, sondern dessen Indexposition. for-Schleifen werden deswegen in R meist als sogennante Zählschleife verwendet. Dazu wird die Funktion seq_along() verwendet, die einen Integer-Vektor erstellt, der genau so lang ist, wie das Objekt, das der Funktion übergeben wird. Solche for-Schleifen haben die allgemeine Form: for (i in seq_along(Objekt)) { Anweisungsblock } Das i steht für iterator und dient als Zählvariable: mit jedem Schleifendurchlauf (Iteration) wird i um Eins erhöht; der Zählbeginn ist 1. In jeder Iteration wird auf das Element i des iterierbaren Objekts zugegriffen. Mithilfe des Iterators i kann also in jeder Iteration auf ein Element aus dem Objekt zugegriffen werden. Klingt kompliziert, wird aber am folgenden Beispiel direkt deutlich: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tiere[i] &lt;- tolower(tiere[i]) } # Änderungen wurden übernommen print(tiere) ## [1] &quot;hund&quot; &quot;elefant&quot; &quot;igel&quot; &quot;katze&quot; Verständnisfragen: Welchen Wert nimmt i im ersten Schleifendurchlauf an? Auf welches Element wird zugegriffen? Welchen Wert nimmt i im dritten Schleifendurchlauf an? Auf welches Element wird zugegriffen? Kann man eine for-Schleife auch dazu verwenden, um über die Spalten einer Matrix / eines Dataframes zu iterieren? Was macht die Funktion seq_along()? Wann empfiehlt es sich, seq_along() in Verbindung mit einer for-Schleife zu verwenden? Auch Zählschleifen können mit bedingten Anweisungen oder Verzweigungen kombiniert werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { if (tiere[i] == &quot;Hund&quot;) { tiere[i] &lt;- tolower(tiere[i]) } else { tiere[i] &lt;- toupper(tiere[i]) } } # Änderungen wurden übernommen print(tiere) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; Im Beispiel oben haben wir mehrmals tiere[i] verwendet. Falls wir uns irgendwann später dazu entscheiden sollten, die Variable tiere umzubenennen, müssten wir alle Vorkommnisse von tiere[i] im Schleifenkörper finden und austauschen. So entstehen schnell Fehler. Um das Problem zu umgehen, könnten wir jetzt auf die Idee kommen, eine “temporäre” Variable zu verwenden, der am Anfang jedes Schleifendurchlaufs das aktuelle Element zugewiesen wird: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tier &lt;- tiere[i] if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } } # Änderungen wurden nicht übernommen! print(tiere) ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; Aber wenn wir uns am Ende den Vektor tiere ausgeben lassen, sehen wir, dass wir den Vektor gar nicht verändert haben! Woran liegt das? Verständnisfragen: Warum wird der Vektor tiere durch das Einfügen einer temporären Variable nicht mehr verändert? Wie könnten wir den Code im Beispiel umschreiben, um das Problem zu beheben? Der Grund für dieses Verhalten liegt wieder in der Unveränderbarkeit der Objekte in R. Um das Problem zu beheben, gibt es verschiedene Möglichkeiten. Die Änderungen, die am Objekt tier vorgenommen wurden, könnten zum Beispiel am Ende der Schleife wieder dem Objekt tiere[i] zugewiesen werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) for (i in seq_along(tiere)) { tier &lt;- tiere[i] if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } # Wert der Variable tier wieder dem Element tiere[i] zuweisen tiere[i] &lt;- tier } # Änderungen wurden übernommen! print(tiere) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; Alternativ kann auch der ursprüngliche Vektor beibehalten werden und die Änderungen in jedem Schleifendurchgang einem neuen Vektor tiere_neu() hinzuzufügt werden. Dafür kann in diesem Fall eine einfache for-Schleife verwendet werden: tiere &lt;- c(&quot;Hund&quot;, &quot;Elefant&quot;, &quot;Igel&quot;, &quot;Katze&quot;) tiere_neu &lt;- c() # leeren Vektor erstellen for (tier in tiere) { if (tier == &quot;Hund&quot;) { tier &lt;- tolower(tier) } else { tier &lt;- toupper(tier) } # Wert der Variable tier als neues Element dem Vektor tiere_neu hinzufügen tiere_neu &lt;- c(tiere_neu, tier) } print(tiere_neu) ## [1] &quot;hund&quot; &quot;ELEFANT&quot; &quot;IGEL&quot; &quot;KATZE&quot; print(tiere) # Vektor tiere ist unverändert ## [1] &quot;Hund&quot; &quot;Elefant&quot; &quot;Igel&quot; &quot;Katze&quot; 3.6 Schleifen abbrechen Es ist zudem möglich, einen Schleifendurchlauf (Iteration) oder die gesamte Schleife abhängig von einer Bedingung frühzeitig abzubrechen. Eine next-Anweisung kann verwendet werden, um den aktuellen Schleifendurchlauf abzubrechen und direkt zum Schleifenkopf zu springen (= Iterationsabbruch). Eine break-Anweisung wird verwendet, um die Schleife komplett abzubrechen (= Schleifenabbruch). Das kann nützlich sein, wenn man fehlende Werte in einem Objekt hat und diese überspringen möchte, damit es zu keiner Fehlermeldung kommt. Die Signalworte next und break können sowohl mit while-Schleifen als auch mit for-Schleifen verwendet werden. Hier ein Beispiel mit einer for-Schleife: # next Anweisung # Vektor mit NA-Werten beliebige_woerter &lt;- c(&quot;Baum&quot;, &quot;Wald&quot;, NA, &quot;Meer&quot;, NA, &quot;Sonne&quot;) # Funktion is.na() überprüft, ob der Wert des Elements wort NA ist for (wort in beliebige_woerter) { if (is.na(wort)) { next } else { print(wort) } } ## [1] &quot;Baum&quot; ## [1] &quot;Wald&quot; ## [1] &quot;Meer&quot; ## [1] &quot;Sonne&quot; # break Anweisung # Vektor mit NA-Werten beliebige_woerter &lt;- c(&quot;Baum&quot;, &quot;Wald&quot;, NA, &quot;Meer&quot;, NA, &quot;Sonne&quot;) # Funktion is.na() überprüft, ob der Wert des Elements wort NA ist for (wort in beliebige_woerter) { if (is.na(wort)) { break } else { print(wort) } } ## [1] &quot;Baum&quot; ## [1] &quot;Wald&quot; Schleifen in R Für die meisten Anwendungen verwendet man in R eher for-Schleifen als while-Schleifen. In vielen Fällen sind Schleifen aber sogar überhaupt nicht notwendig. In der nächsten Stunde werden wir sehen, dass Schleifen in vielen Fällen durch bestimmte Funktionen ersetzt werden können. Da R im Kern eine sogenannte “funktionale” Programmiersprache ist, werden Schleifen weniger verwendet als in anderen Programmiersprachen. Quellen Venables, W.N. and Smith, D.M. and the R Core Team. An Introduction to R, https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf Wickham, Hadley. The Tidyverse Style Guide, https://style.tidyverse.org/ Reussner, Ralf H. Mitschnitt zur Vorlesung “Programmieren” im WiSe 2015/2016. 03: Kontrollstrukturen, https://www.youtube.com/watch?v=-ZvrABPvUdA Wickham, Hadley and Grolemund, Garrett. R for Data Science: Iteration, https://r4ds.had.co.nz/iteration.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
